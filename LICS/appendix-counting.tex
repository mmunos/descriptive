
\medskip

%%% DEMOSTRACION DE SQSO(FO) y #P
\subsection*{Proof of Proposition~\ref{prop:capture-shP}}

We will construct a recursive non-deterministic algorithm $M_{\alpha}$ for each $\eqso(\fo)$ formula $\alpha$ over a signature $\R$. This machine, on input $(\A,v,V)$ accepts in $\sem{\alpha}(\A,v,V)$ of its non-deterministic paths for each $(\A,v,V) \in \ostr[\R]^*$. Suppose $\A$ has domain $A$. If $\alpha$ is a $\fo$-formula $\varphi$, then the algorithm checks if $(\A,v,V)\models\varphi$ deterministically in polynomial time, and accepts if and only if it holds true. If $\alpha$ is a constant $s$, it produces $s$ branches and accepts in all of them. If $\alpha = (\beta \add \gamma)$, then it chooses between 0 or 1, if it is 0 (1), it simulates $M_{\beta}$ ($M_{\gamma}$) on input $(\A,v,V)$. 
%If $\alpha = (\beta \mult \gamma)$, it simulates $M_{\beta}$ on input $(\A,v,V)$ and on each accepting path, it continues simulating $M_{\gamma}$ on input $(\A,v,V)$.
If $\alpha = \sa{x}\beta$, it chooses $a\in A$ and simulates $M_{\beta}$ on input $(\A,v[a/x],V)$.
%If $\alpha = \pa{x}\beta$, it simulates $M_{\beta}$ on input $(\A,v[a/x],V)$ consecutively for each $a\in A$. 
If $\alpha = \sa{X}\beta$, it chooses $B\in A^{arity(X)}$ and simulates $M_{\beta}$ on input $(\A,v,V[B/X])$. This covers all possible cases for $\alpha$. Let $\alpha$ be a formula in $\eqso(\fo)$ over a signature $\R$ and let $f$ be a function over $\R$ such that $f(\enc(\A))$ is equal to the accepting paths of $M_{\alpha}$ on input $(\A,v,V)$ for some $(\A,v,V) \in \ostr[\R]^*$. We have that $f$ is a $\shp$-function over $\R$ and $f(\enc(\A)) = \sem{\alpha}(\A)$ for every $\A\in\ostr[\R]$.

For the other direction, note that Saluja et al.~\cite{SalujaST95} proved that $\shp = \sfo$. 
%We also have that $\sqso(\fo)$ captures $\#\fo$ over ordered structures so for each $f\in \shp$ let $\alpha \in \sqso(\fo)$ be its corresponding formula. 
Since a function in $\sfo$ can also be defined $\eqso(\fo)$ (see Section~\ref{sec:previous}), the condition holds. \qed

\medskip

%%% DEMOSTRACION DE SQSO(ESO) y span-P
\subsection*{Proof of Proposition~\ref{prop:capture-spanP}}

Similar than the previous proof, we will construct a recursive non-deterministic algorithm $M_{\alpha}$ for each $\eqso(\eso)$ formula $\alpha$ over a signature $\R$. This machine, on input $(\A,v,V)$, non-deterministically produces $\sem{\alpha}(\A,v,V)$ distinct accepting outputs for each $(\A,v,V) \in \ostr[\R]^*$. Suppose $\A$ has domain $A$. 
If $\alpha$ is a $\eso$-formula $\varphi$ it checks if $(\A,v,V)\models\varphi$ non-deterministically in polynomial time \cite{fagin1974generalized}, and accepts if and only if the condition holds true. 
If $\alpha$ is a constant $s$, then the algorithm produces $s$ branches and accepts in all of them. 
If $\alpha = (\beta \add \gamma)$, then it chooses between 0 or 1, if it is 0 (1), it simulates $M_{\beta}$ ($M_{\gamma}$) on input $(\A,v,V)$.  
If $\alpha = \sa{x}\beta$, it chooses $a\in A$ and simulates $M_{\beta}$ on input $(\A,v[a/x],V)$. 
If $\alpha = \sa{X} \beta$, it chooses $B\in A^{\arity(X)}$ and simulates $M_{\beta}$ on input $(\A,v,V[B/X])$. 
This covers all possible cases for $\alpha$.
Additionally, the algorithm produces a different output on each path. This can be done by printing the trace of all the non-deterministic choices.
However, when the algorithm starts checking whether $(\A,v,V)\models\varphi$ for some $\eso$ formula $\varphi$, it stops printing in the output tape. This way the algorithm produces exactly one output from that point onwards.
Let $\alpha$ be a formula in $\eqso(\eso)$ over a signature $\R$ and let $f$ be a function over $\R$ such that $f(\enc(\A))$ is equal to the number of accepting outputs of $M_{\alpha}$ on input $(\A,v,V)$ for some $(\A,v,V) \in \ostr[\R]^*$. 
We have that $f$ is a $\spp$ function over $\R$ and that $f(\enc(\A)) = \sem{\alpha}(\A)$ for every $\A\in\ostr[\R]$.

For the other direction, Compton et al.~\cite{ComptonG96} proved that $\spp = \#\eso$. Since a function in $\#\eso$ can also be defined in $\eqso(\eso)$, then $\eqso(\eso)$ captures $\spp$ over ordered structures.

\medskip

%%% DEMOSTRACION DE QFO(LFP) y FP
\subsection*{Proof of Theorem~\ref{theo:capture-fp}}

For the first condition, let $\alpha\in\qfo(\lfp)$ over some signature $\R$. Let $f$ be a function over $\R$ defined by the following procedure. Let $\enc(\A)$ be an input, where $\A$ is an ordered structure over $\R$ with domain $A = \{1,\ldots,n\}$. In the procedure we slightly extend the grammar of $\qfo(\lfp)$ to include constants. We replace each first order sum and first order product in $\alpha$ by an expansion using the elements in $A$. This is, $\sa{x} \beta(x)$ is replaced by $(\beta(1)+\cdots+\beta(n))$ and $\pa{x}\beta(x)$ is replaced by $(\beta(1)\cdot\,\cdots\,\cdot\beta(n))$. Then each sub-formula $\varphi\in\lfp$ in $\alpha$ is evaluated in polynomial time and replaced by 1 if $\A\models\varphi$ and by 0 otherwise. The resulting formula is an arithmetic expression of polynomial size which is evaluated and lastly given as output. Note that $f\in\fp$ and $f(\enc(\A)) = \sem{\alpha}(\A)$.
	
For the second condition, let $f\in \fp$ defined over some signature $\R$.
Let $\ell\in\nat$ be such that for each $\A\in\ostr[\R]$, $\lceil\log_2 f(\enc(\A)) \rceil \leq n^\ell$, where $\A$ has a domain of size $n$.
Let $\bar{x} = (x_1,\ldots,x_{\ell})$.
Consider a procedure that receives $\enc(\A)$ and an assignation $\bar{a}$ to $\bar{x}$. Let $m$ be the position of $\bar{a}$ in the lexicographic order of the tuples in $A^{\ell}$. The procedure then computes the $m$-th bit of $f(\enc(\A))$, from least to most significant. Since this procedure works in polynomial time, it can be described by an $\lfp$ formula $\Phi(\bar{x})$. Then we use
$$
\alpha = \sa{\bar{x}} \Phi(\bar{x})\cdot\varphi(\bar{x}),
$$
where $\varphi(\bar{x}) := \pa{\bar{y}}(\bar{y} < \bar{x} \mapsto 2).$ Note that if $\bar{a} \in A^{\ell}$ is the $m$-th tuple in the given order (starting from 0), then $\sem{\varphi(\bar{a})}(\A) = 2^{m}$. Adding these values for each $\bar{a}\in A^{\ell}$ gives exactly $f(\enc(\A))$. Then, $\alpha$ is in $\qfo(\lfp)$ over $\R$ and $\sem{\alpha}(\A) = f(\enc(\A))$.

\medskip

%%% DEMOSTRACION DE QSO(PFP) y FPSPACE
\subsection*{Proof of Theorem~\ref{theo:capture-fpspace}}

To show how to evaluate a $\qso(\pfp)$-formula, we will construct a recursive non-deterministic algorithm $M_{\alpha}$ for each $\qso(\pfp)$ formula $\alpha$ over a signature $\R$. This machine runs in non-deterministic polynomial space and, on input $(\A,v,V)$, accepts in $\sem{\alpha}(\A,v,V)$ of its non-deterministic paths for each $(\A,v,V) \in \ostr[\R]^*$. Suppose $\A$ has domain $A$. If $\alpha$ is a $\pfp$-formula $\varphi$, then the algorithm checks if $(\A,v,V)\models\varphi$ deterministically in polynomial space~\cite{L04}, and accepts if and only if it holds true. If $\alpha$ is a constant $s$, it produces $s$ branches and accepts in all of them. If $\alpha = (\beta \add \gamma)$, then it chooses between 0 or 1, if it is 0 (1), it simulates $M_{\beta}$ ($M_{\gamma}$) on input $(\A,v,V)$. If $\alpha = (\beta \mult \gamma)$, it simulates $M_{\beta}$ on input $(\A,v,V)$ and on each accepting path, it continues simulating $M_{\gamma}$ on input $(\A,v,V)$.
If $\alpha = \sa{x}\beta$, it chooses $a\in A$ and simulates $M_{\beta}$ on input $(\A,v[a/x],V)$. If $\alpha = \pa{x}\beta$, it simulates $M_{\beta}$ on input $(\A,v[a/x],V)$ consecutively for each $a\in A$. If $\alpha = \sa{X}\beta$, it chooses $B\in A^{arity(X)}$ and simulates $M_{\beta}$ on input $(\A,v,V[B/X])$. If $\alpha = \pa{X}\beta$, it simulates $M_{\beta}$ on input $(\A,v,V[B/X])$ consecutively for each $B\in A^{arity(X)}$. This covers all possible cases for $\alpha$, and each of these steps can be computed in polynomial space. Let $\alpha$ be a formula in $\qso(\pfp)$ over a signature $\R$ and let $f$ be a function over $\R$ such that $f(\enc(\A))$ is equal to the accepting paths of $M_{\alpha}$ on input $(\A,v,V)$ for some $(\A,v,V) \in \ostr[\R]^*$. We have that $f$ is a $\shpspace$ function over $\R$, which implies that $f$ is also a $\fpspace$ function over $\R$, by the fact that $\shpspace = \fpspace$ \cite{Ladner89}, and that $f(\enc(\A)) = \sem{\alpha}(\A)$ for every $\A\in\ostr[\R]$.

For the second condition, let $f\in \fpspace$ defined over some $\R$. Let $\ell\in\nat$ be such that for each $\A\in\ostr[\R]$, $\lceil\log_2 f(\enc(\A)) \rceil \leq 2^{n^\ell}$, where $\A$ has a domain of size $n$. Let $X$ be a second-order variable of arity $\ell$. Consider a linear order over predicates of arity $\ell$ given by the formula 
$$
\varphi_{<}(X,Y) = \exists\bar{u}\big[\neg X(\bar{u})\wedge Y(\bar{u})\wedge \forall\bar{v}\big(
\bar{u}<\bar{v}\to(X(\bar{u})\iff Y(\bar{v}))\big)\big].
$$
Consider a polynomial space algorithm over $\R\cup\{X\}$ that receives a $\R\cup\{X\}$-structure $\A'$. Let $X^{\A'}$ be the $p$-th subset in the given order (we consider 0-indexation). The algorithm computes $f(\enc(\A))$ until $(2^{n^{\ell}}-p)$ characters have been written, but each character of the output is written over the last one. It accepts if and only if the last character written is $1$. Since this algorithm works in polynomial space, it can be described in $\pfp$ \cite{AbiteboulV89} by a formula $\Phi(X)$.

Note that the formula also represents the following.
For each $(\A,v,V)\in\ostr[\R]^*$, let $V(X)$ be the $p$-th subset with respect to this order and let $w$ be a string of size $2^{n^{\ell}}$ which represents the value of $f(\enc(\A))$ in binary. Then $(\A,v,V)\models\Phi(X)$ if and only if the $p$-th bit in $w$ is 1, from least to most significant. We define
$$
\alpha := \sa{X}(\Phi(X)\mult\varphi(X)),
$$ 
where $\varphi(X) = \pa{Y}(\varphi_{<}(Y,X)\mapsto 2)$. Note that for each $B\subseteq A^{\ell}$ such that $B$ is the $m$-th element in the given order, $\sem{\varphi(B)}(\A) = 2^m$. Therefore, $\alpha\in\qso(\pfp)$ and $\sem{\alpha}(\A) = f(\enc(\A))$.

\medskip


%%% DEMOSTRACION DE QFO(PFP) y FPSPACE(poly)
\subsection*{Proof of Corollary~\ref{cor:capture-fpspace-poly}}

For the first condition, let $\alpha\in\qfo(\pfp)$ over some signature $\R$. Let $f$ be a function over $\R$ defined by the following procedure. Let $\enc(\A)$ be an input, where $\A$ is an ordered structure over $\R$ with domain $A = \{1,\ldots,n\}$. In the procedure we slightly extend the grammar of $\qfo(\pfp)$ to include constants. We replace each first order sum and first order product in $\alpha$ by an expansion using the elements in $A$. This is, $\sa{x} \beta(x)$ is replaced by $(\beta(1)+\cdots+\beta(n))$ and $\pa{x}\beta(x)$ is replaced by $(\beta(1)\cdot\,\cdots\,\cdot\beta(n))$. Then each sub-formula $\varphi\in\pfp$ in $\alpha$ is evaluated in polynomial space and replaced by 1 if $\A\models\varphi$ and by 0 otherwise. The resulting formula is an arithmetic expression of polynomial size which is evaluated and lastly given as output. Note that $f\in\nfpspace$ and $f(\enc(\A)) = \sem{\alpha}(\A)$.

For the second condition, let $f\in \fpspace$ defined over some signature $\R$.
Let $\ell\in\nat$ be such that for each $\A\in\ostr[\R]$, $\lceil\log_2 f(\enc(\A)) \rceil \leq n^\ell$, where $\A$ has a domain of size $n$.
Let $\bar{x} = (x_1,\ldots,x_{\ell})$.
Consider a procedure that receives $\enc(\A)$ and an assignation $\bar{a}$ to $\bar{x}$. Let $m$ be the position of $\bar{a}$ in the lexicographic order of the tuples in $A^{\ell}$. The procedure then computes the $m$-th bit of $f(\enc(\A))$, from least to most significant. Since this procedure works in polynomial space, it can be described by an $\pfp$ formula $\Phi(\bar{x})$. Then we use
$$
\alpha = \sa{\bar{x}} \Phi(\bar{x})\cdot\varphi(\bar{x}),
$$
where $\varphi(\bar{x}) := \pa{\bar{y}}(\bar{y} < \bar{x} \mapsto 2).$ Note that if $\bar{a} \in A^{\ell}$ is the $m$-th tuple in the given order (starting from 0), then $\sem{\varphi(\bar{a})}(\A) = 2^{m}$. Adding these values for each $\bar{a}\in A^{\ell}$ gives exactly $f(\enc(\A))$. Then, $\alpha$ is in $\qfo(\pfp)$ over $\R$ and $\sem{\alpha}(\A) = f(\enc(\A))$.

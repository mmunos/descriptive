%!TEX root = main.tex

\textbf{Proof of Theorem \ref{no-mult}}

Let $\{+, \cdot, \Sigma, \Pi\}$ be the set of {\it algebraic operators} in $\qso$. We will prove by induction over the number of algebraic operators in a $\qso$-formula $\alpha$ that there exists some $\qso$-formula $\alpha'$ that respects the stated condition. Let $\text{op}(\alpha)$ be the number of algebraic operators in $\alpha$. The case $\text{op}(\alpha) = 0$ is trivial. Let $n\in\nat$ be such that for each $\qso$-formula $\beta$ such that $\text{op}(\beta) < n$ there is some $\beta'$ that respects the condition. Let $\alpha$ be a $\qso$-formula such that $\text{op}(\alpha) = n$. Note that if $\alpha$ is of the form $\alpha = (\beta_1 + \beta_2)$, $\alpha = \Sigma x \beta$, $\alpha = \Pi x \beta$, $\alpha = \Sigma X \beta$ or $\alpha = \Pi X \beta$ the proof follows directly. Therefore we assume that $\alpha = (\beta_1 \cdot \beta_2)$. We separate the proof in two main cases:
\begin{enumerate}
	\item At least one of $\beta_1, \beta_2$ is not of the form $\Pi x \gamma$, $\Pi X \gamma$, or $\varphi$, where $\varphi$ is an $\so$-formula. Without loss of generality, let $\beta_1$ be such one.
	\begin{enumerate}
		\item $\beta_1 = s \in \nat$. Then we use $\alpha' = \beta_2 + \cdots + \beta_2$, where $\beta_2$ is repeated $s$ times, and if $s = 0$, take $\alpha' = \perp$. Since each of the formulas paired by $+$ has less than $n$ algebraic operators, the statement holds.
		\item $\beta_1 = (\gamma_1 + \gamma_2)$. Then, we use $\alpha' = (\gamma_1\cdot\beta_2 + \gamma_2\cdot\beta_2)$ and each of the formulas paired by $+$ have less than $n$ algebraic operators so the statement holds.
		\item $\beta_1 = \Sigma x \gamma$. Then, we use $\alpha' = \Sigma x (\gamma\cdot\beta_2)$ and as in the previous case the statement holds.
		\item $\beta_1 = \Sigma X \gamma$, which we treat exactly as the previous one.
	\end{enumerate}
	\item Both of $\beta_1$ and $\beta_2$ are of the form $\Pi x \gamma$, $\Pi X \gamma$, or $\varphi$, where $\varphi$ is an $\so$-formula. This case also separates in further cases. We define $(\varphi \mapsto \alpha) := (\neg\varphi + (\varphi\cdot\alpha))$ for which $\sem{(\varphi \mapsto \alpha)}(\A,v,V)$ equals $\sem{\alpha}(\A,v,V)$ when $(\A,v,V)\models\varphi$ and 1 otherwise.
	\begin{enumerate}
		\item $\beta_1 = \Sigma x \gamma_1(x)$ and $\beta_2 = \Sigma y \gamma_2(y)$. Then we use $\alpha' = \Sigma x(\gamma_1(x)\cdot\gamma_2(x))$, and the statement holds.
		\item $\beta_1 = \Sigma X \gamma_1(X)$ and $\beta_2 = \Sigma Y \gamma_2(Y)$. [something about arities].
		\item $\beta_1 = \Sigma X \gamma_1(X)$ and $\beta_2 = \Sigma x \gamma_2(x)$ (w.l.o.g.). [use singleton predicates].
		\item $\beta_1 = \Sigma x \gamma$ and $\beta_2 = \varphi$, which is an $\so$-formula (w.l.o.g.). Then, we use $\alpha' = \Sigma x (\gamma \cdot \varphi)$, and the statement holds.
		\item $\beta_1 = \Sigma X \gamma$ and $\beta_2 = \varphi$, which is an $\so$-formula (w.l.o.g.). We treat this case exactly as the previous one.
		\item $\beta_1 = \varphi_1$ and $\beta_2 = \varphi_2$ both $\so$-formulas. Then, we use $\alpha' = (\varphi_1 \wedge \varphi_2)$ and the statement holds.
	\end{enumerate}
\end{enumerate}


\textbf{Proof of Theorem \ref{captfp}}

For the first condition, let $\alpha\in\qfo(\lfp)$, $\A\in\ostr$, $v$ and $V$ a first and second order assignment for $\A$, respectively. To evaluate $\sem{\alpha}(\A,v,V)$, we replace each first order sum and first order product by their corresponding expansion. This is, $\Sigma x \beta(x)$ is replaced by $(\beta(a_1)+\cdots+\beta(a_n))$, where $A = \{a_1,\ldots,a_n\}$, and $\Pi x \beta(x)$ is replaced by $(\beta(a_1)\cdot\,\cdots\,\cdot\beta(a_n))$. Then we replace each logic sub-formula $\varphi$ in $\alpha$ by their evaluated value, 0 or 1. Since each of this formulas is in $\lfp$, this can be done in polynomial time. The resulting formula is an arithmetic expression, which can be evaluated recursively in polynomial time.
	
For the second condition, let $f\in \fp$. Let $k\in\nat$ be such that $\vert f(\A) \vert = \vert A \vert^k$ for each $\A\in\ostr[\R]$. Let $\Phi(x_0,\ldots,x_{k-1})$ be a $\lfp$ formula such that $(\A,a_0,\ldots,a_{k-1})\models\Phi$ if and only if in the string $y = f(\A)$ there is 1 in the $(\vert A \vert^{k-1}m_{k-1} + \cdots + \vert A \vert^2 m_2 + \vert A \vert m_1 + m_0)$-th position from right to left, and where $a_i$ is the (0-indexed) $m_i$-th element of $A$. We use
	$$
	\alpha = \Sigma x_0 \cdots \Sigma x_{k-1} \Phi(x_0,\ldots,x_{k-1})\cdot\varphi_{k-1}(x_{k-1})\cdot\,\cdots\,\cdot\varphi_0(x_0).
	$$
	where $\varphi_i(x) = \Pi y[(y < x)\mapsto\Pi z_1\cdots\Pi z_i\,2]$ for $i > 0$ and $\varphi_0(x) = \Pi y[(y < x)\mapsto 2]$. Note that if $a$ is the  $m$-th element in $A$, then $\sem{\varphi_i(x)}(\A,a) = 2^{\vert A \vert^i m}$. Therefore, for each $(a_0,\ldots,a_{k-1})\in A^k$, we have that $\sem{\Phi(x_0,\ldots,x_{k-1})\cdot\varphi_{k-1}(x_{k-1})\,\cdots\,\varphi_0(x_0)}(\A,a_0,\ldots,a_{k-1}) = 2^{(\vert A \vert^{k-1}m_{k-1} + \cdots + \vert A \vert^2 m_2 + \vert A \vert m_1 + m_0)}$ if $(\A,a_0,\ldots,a_{k-1})\models\Phi$ and 0 otherwise, and adding these values gives $f(\A)$. 	

\textbf{Proof of Theorem \ref{qfo-pfp-cap}}

For the first condition, we use the exact same procedure as in Theorem \ref{captfp}, noting that evaluating each of the $\pfp$ formulas can be done in polynomial space, and that the result is also polynomial on the size of the input.

For the second condition, note that for each function $f\in \nfpspace$, $\vert f(\A) \vert$ is polynomial on $\vert A \vert$. Thus, there is a $\pfp$ formula $\Phi$ that models the string $f(\A)$ bitwise. The rest of the proof is analogous to Theorem \ref{captfp}.

\textbf{Proof of Theorem \ref{eqso-fo-cap}}


\textbf{Proof of Theorem \ref{eqso-fo-cap-not}}


\textbf{Proof of Theorem \ref{eqso-eso-cap}}


\textbf{Proof of Theorem \ref{one-sigma-zero}}

Towards a contradiction, suppose that there exists a constant function $f(\A) = s > 0$ which is expressible in $\E{0}$. This is, there is a formula $\psi(x,X)$ such that $f_{\psi(x,X)}(\A) = \vert \{ \langle e,P\rangle \mid \A\models\psi(e,P) \} \vert = s$ for each $\A\in\ostr$. It can be seen that if $X$ contains more than zero variables, then the function $f_{\psi(x,X)}$ grows exponentially. We have now that $\psi(x)$ contains only first order variables. Consider some $\A \in \ostr$ of size $n$ and let $a_1,\ldots,a_s\in \A$ be the tuples that satisfy $\A \models \psi(a_i)$. Now consider a structure $\A'$ that is obtained by duplicating $\A$. This is, $\A'$ has size $2n$, its first half is isomorphic to its second half, and also to $\A$. We have that there is at least $2s$ tuples $a_i,b_i\in \A'$, $s$ on each half, such that $\A'\models\psi(a_i)$ and $\A'\models\psi(b_i)$, which leads to a contradiction.

\textbf{Proof of Theorem \ref{mult-sigma-zero}}

Let $\alpha \in \sqso(\loge{0})$ with binary product. This is, $\alpha$ is defined by the grammar $\alpha := \sa{x}\varphi \ \mid \ \sa{X}\varphi \ \mid \ \sa{x}\alpha \ \mid \ \sa{X}\alpha \ \mid \ (\alpha\mult\alpha)$, where $\varphi \in \loge{0}$. For convenience, we add the expressions $\sa{x}(\varphi\mult\varphi)$ and $\sa{X}(\varphi\mult\varphi)$ to the grammar. Let $k$ be the number of algebraic operators in $\alpha$. We will show by induction on $k$ that $\alpha$ is expressible without multiplication. If $k = 1$, then the possible cases are $\alpha = \sa{x}\varphi$, where $\varphi\in\loge{0}$, which is already product-free. If $k = 2$, then the only that is not two nested summations is $\alpha = \sa{x}(\varphi\mult\psi)$, which can be expressed as $\alpha = \sa{x}(\varphi\wedge\psi)$. Suppose that the hypothesis holds for $k = 1$ through $n-1$. Let $\alpha$ have $n$ algebraic operators. If $\alpha = \sa{x}\beta$ or $\alpha = \sa{X}\beta$ where $\beta$ is an algebraic expression, then $\beta$ has $n-1$ algebraic operators and by hypothesis it can be expressed as product-free. If $\alpha = (\beta \mult \gamma)$ there are two cases. If at least one between $\beta$ and $\gamma$ has a product, then by hypothesis it can be expressed as product-free. Moreover, the new expression for $\alpha$ has strictly less than $n$ algebraic operators so by hypothesis it can be expressed as product-free. If there are no products in $\beta$ or $\gamma$, then let $\beta = \sa{x}\delta(x)$. We have that $\alpha$ can be expressed as $\sa{y}(\delta(y)\mult\gamma)$, where $y$ is a first-order variable that does not appear in $\beta$ or $\gamma$. Since $\delta(y)\mult\gamma$ has $n-1$ algebraic operators, it can be expressed as product-free, and then $\alpha$ can be expressed as product-free.

\textbf{Proof of Theorem \ref{fo-prod-sigma-zero}}

The resulting grammar is $\alpha := \sa{x}\varphi \ \mid \ \sa{X} \varphi \ \mid \ \sa{x}\alpha \ \mid \ \sa{X}\alpha \ \mid \pa{x}\alpha$. Consider a more restricted grammar that replaces $\pa{x}\alpha$ by $\pa{x}\sa{y}\varphi$. Let $\alpha = \pa{x}\sa{y}(x = y)$. This formula produces a constant function equal to 1, which as shown in Theorem \ref{one-sigma-zero} is not expressible in $\E{0}$. 

\textbf{Proof of Theorem \ref{fp1}}

Let $f \in \XE{0}$, and let $\varphi(\X,\x)$ be and {\sc FO}-extended quantifier-free $\L$-formula such that:
\begin{eqnarray*}
	f(\A) &=& \vert \{\langle \P,\e  \rangle \mid \A \models \varphi(\P,\e) \} \vert
\end{eqnarray*}
for each $\A = \langle A, \S^{\A}, \leq^{\A} \rangle \in \str$, where $\e \in A^m$ and $\P = (P_1,\ldots,P_q)$ is a tuple of predicates. We will now show that computing $f(\A)$ can be done in polynomial time.

For each {\sc FO}-formula $\beta(\x)$ in $\varphi(\X,\x)$, let $R_{\beta}$ be a predicate of arity $m$. Let $\A^\prime = \langle A, \S^{\A}, R_{\beta}^{\A^\prime}, \leq^{\A} \rangle \in \str$, where $R_{\beta}^{\A^\prime} = \{\d \mid \A \models \beta(\d)\}$. Note that each $\beta(\x)$ is fixed in $\varphi(\X,\x)$, and for each $\d \in A^m$, checking whether $\A \models \beta(\d)$ can be done in polynomial time. Therefore, generating $R_{\beta}^{\A^\prime}$ can also be done in polynomial time.

Let $\psi(\X,\x)$ be obtained by replacing each {\sc FO}-formula $\beta(\x)$ in $\varphi(\X,\x)$ by $R_{\beta}(\x)$. Also, let $g = f_{\psi(\X,\x)}$. Note that for each tuple of predicates $\P$ and each $\e \in A^m$, $\A \models \varphi(\P,\e)$ if and only if $\A^\prime \models \psi(\P,\e)$, and so, $g(\A^\prime) = f(\A)$. But, $\psi(\X,\x)$ is a quantifier-free $\L$-formula, and therefore, $g \in \#\Sigma_0$. Since it is shown in \cite{DBLP:journals/jcss/SalujaST95} that $\#\Sigma_0 \subseteq$ {\sc FP}, we conclude that $f(\A)$ can be evaluated in polynomial time.
	
\textbf{Proof of Theorem \ref{decisionptime}}

Let $f$ be a function in $\E{1}$. Then there is an extended quantifier-free $\L-$formula $\varphi(\x,\X,\z)$ such that
\begin{eqnarray*}
	f(\A) &=& \mid \{ \langle\P,\e\rangle \mid \A \models \exists \x \, \varphi(\x,\P,\e) \} \mid,
\end{eqnarray*}
where $\A = \langle A, \S^{\A}, \leq^{\A} \rangle \in \str$, $A = \{a_1,\ldots,a_{\vert A \vert}\}$, $\z$ is an $m$-tuple of variables and $\x$ is a $k$-tuple of variables. Let $\y = (\x,\z)$ and let $\psi(\X,\y) = \varphi(\x,\X,\z)$. Moreover, let $g = f_{\psi(\X,\y)}$.
\begin{claim} \label{mono}
	For each $\A \in \str$, $f(\A) > 0$ iff $g(\A) > 0$.
\end{claim}
\begin{proof}
	($\Rightarrow$) Suppose $f(\A) > 0$. Let $\P$ and $\e$ be such that $\A \models \exists \x \, \varphi(\x,\P,\e)$. It follows that there is at least one $\d \in A^k$ such that $\A \models \varphi(\d,\P,\e) = \psi(\P,(\d,\e))$. Therefore, $g(\A) > 0$. 
	
	($\Leftarrow$) Suppose $g(\A) > 0$. Let $\Q$ and $\c = (\c_1,\c_2)$, where $\c_1$ and $\c_2$ have $k$ and $m$ elements respectively, be such that $\A \models \psi(\Q,\c) = \varphi(\c_1,\Q,\c_2)$. Then we have that $\A \models \exists \x \, \varphi(\x,\Q,\c_2)$, from which we conclude that $f(\A) > 0$.
\end{proof}
Note that $\psi(\X,\y)$ is an {\sc FO}-extended $\L$-formula, so $g \in\XE{0}$. It follows from \ref{mono} that for each $\A \in \str$, it holds that $\A \in L_f$ if and only if $g(\A) > 0$. But by Theorem \ref{fp1}, $g(\A)$ can be evaluated in polynomial time. From this we conclude that the decision version of $f$ is in $\ptime$.
	
\textbf{Proof of Theorem \ref{sub-pnp}}

Suppose that $\E{1}$ is closed under substraction, that is, for each pair of functions $f,g\in \E{1}$, there exists $h\in\E{1}$ such that $(f\dotminus g)(\A) = h(\A)$ for each $\A\in\str$.

Let $\A = \langle A, S_1^\A, S_2^\A, S_3^\A, S_4^\A, \leq^\A \rangle$ be an $\L-$structure that represents an instance of a 3DNF formula $\Phi$, where $A$ is the set of variables mentioned in $\Phi$, $S_i^\A$ is a ternary relation described as follows, for each $i\in\{1,2,3,4\}$:
\begin{eqnarray*}
	S_1^\A &=& \{(a_1,a_2,a_3)\mid (\neg a_1 \wedge \neg a_2 \wedge \neg a_3) \mbox{ appears as a disjunct in }\Phi\},\\
	S_2^\A &=& \{(a_1,a_2,a_3)\mid ( a_1 \wedge \neg a_2 \wedge \neg a_3) \mbox{ appears as a disjunct in }\Phi\},\\
	S_3^\A &=& \{(a_1,a_2,a_3)\mid ( a_1 \wedge  a_2 \wedge \neg a_3) \mbox{ appears as a disjunct in }\Phi\},\\
	S_4^\A &=& \{(a_1,a_2,a_3)\mid ( a_1 \wedge  a_2 \wedge  a_3) \mbox{ appears as a disjunct in }\Phi\}.
\end{eqnarray*}
Now we define $f_{\#3DNF} = f_{\psi(T)}$ where
\begin{multline*}
\psi(T) = \exists x \exists y \exists z\, [(S_1(x,y,z) \wedge \neg T(x) \wedge \neg T(y) \wedge \neg T(z)) \vee (S_2(x,y,z) \wedge T(x) \wedge \neg T(y) \wedge \neg T(z)) \, \vee \\ (S_3(x,y,z) \wedge T(x) \wedge T(y) \wedge \neg T(z)) \vee (S_4(x,y,z) \wedge T(x) \wedge T(y) \wedge T(z))].
\end{multline*}
Note that $f_{\#3DNF} \in \#\Sigma_1$. Let $f_{all} = f_{\exists x\:\varphi(x,X)}$, where
$$
\varphi(x,X) = (T(x) \vee \neg T(x)).
$$
Note that $f_{all}$ counts every possible truth assignment (satisfying or not) to a 3DNF formula. Given that $f_{\#3DNF}, f_{all} \in \E{1}$, we have by our initial assumption that $f_{all}-f_{\#3DNF} \in \E{1}$. Let $h\in\E{1}$ be such that $h = f_{all}-f_{\#3DNF}$. For each structure $\A$ that represents a 3DNF formula $\psi$, it holds that $h(\A) = f_{all}(\A)-f_{\#3DNF}(\A) = 0$ if and only if $\psi$ is a tautology, so the decision version $L_h$ of $f_{all}-f_{\#3DNF}$ is $\conp$-complete. However, as we showed previously in Theorem \ref{decisionptime}, since $h\in\E{1}$, we have that $L_h \in \ptime$. Then, $\conp \subseteq \ptime$, from which we conclude that $\ptime = \np$.
	
\textbf{Proof of Theorem \ref{sigma1strict}}

We will show that the $\E{1}$ function $f$ defined by $\varphi(x_1) = (x_1 = x_1) \wedge \forall y \, S(y)$ is not in $\#\Sigma_1$. By contradiction, suppose that it is. Let $\A = \langle A =\{1\},S^\A = \{1\},\leq^\A=\{(1,1)\} \rangle$. Then, $f(\A) = 1$. Now let $\B = \langle B =\{1,2\},S^\B = \{1\},\leq^\B=\{(1,1),(1,2),(2,2)\} \rangle$. Note that $\A$ is an induced substructure of $\B$.

We have that for each function $g \in \#\Sigma_1$ and structures $\A_1,\A_2\in\str$, if $\A_1$ is an induced substructure of $\A_2$, then $g(\A_1) \leq g(\A_2)$ \cite{DBLP:journals/jcss/SalujaST95}. Therefore, $f(\B) \geq f(\A) = 1$. However, there is no assignment $s\in B$ to $x$ such that $\B\models\:\varphi(s)$, so $f(\B) = 0$, which leads to a contradiction.
	
\textbf{Proof of Theorem \ref{sigmafo-minusone}}

Consider an $\L$-formula of the form $\exists\x\:\varphi(\x,\X,\z)$ where $\z = (z_1,\dots,z_d)$ and $\X = (X_1,\dots,X_r)$. There are three possibilities regarding the size of the tuples of free variables $\z$ and $\X$: (1) $d>0$ and $r=0$ (2) $d=0$ and $r>0$ (3) $d,r>0$. This separates the proof in three cases:
\begin{enumerate}
	\item Let $f \in \E{1}$ be defined by an extended quantifier free $\L$-formula $\varphi(\x,\z)$, where $\z = (z_1,\dots,z_d)$. That is,
	\begin{eqnarray*}
		f(\A) &=& \mid \{ \langle\e\rangle \mid \A \models \exists \x \ \varphi(\x,\e) \} \mid,
	\end{eqnarray*}
	for every $\A = \langle A, \S^{\A}, \leq^{\A} \rangle \in \str$, where $\e \in A^d$. Our goal here is to eliminate the lexicographically smallest sequence of variables, which can be done easily. First, let $\y = (y_1,\dots,y_k)$, $\y\,^\prime = (y_1^\prime,\dots,y_k^\prime)$ and
	\begin{eqnarray*}
		\varphi_{k,<}(\y\,^\prime,\y) &=& \bigvee_{i = 1}^k \left( \bigwedge_{j=1}^{i-1} y_j^\prime = y_j \wedge y_i^\prime < y_i \right).
	\end{eqnarray*}
	This formula is true if $\y\,^\prime$ is lexicographically smaller than $\y$. Now, let $f'$ be defined by
	\begin{eqnarray*}
		\varphi^\prime(\x,\z) &=& \varphi(\x,\z) \wedge \exists \z\,^\prime (\varphi(\x,\z\,^\prime) \wedge \varphi_{d,<}(\z\,^\prime,\z ) ).
	\end{eqnarray*}
	If $f(\A)>0$, then $f'(\A)$ will count exactly one element less than $f(\A)$. Otherwise, if $f(\A)=0$, then $\A \not\models\exists \x\,\varphi(\x,\e)$ for every tuple $\e$ of elements in $A$, so $\A \not\models\exists \x\,\varphi^\prime(\x,\e)$ for every $\e$ and, therefore, $f'(\A)=0$. Hence, $f' = f\dotminus 1,$ from which we conclude that $f\dotminus 1\in\E{1}.$
	
	\item Let $f \in \E{1}$ be defined by an extended quantifier free $\L$-formula $\varphi(\x,\X)$ where $\x = (x_1,\dots,x_d)$ and $\X = (X_1,\dots,X_r)$. That is,
	\begin{eqnarray*}
		f(\A) &=& \mid \{ \langle\P\rangle \mid \A \models \exists \x \ \varphi(\x,\P) \} \mid \label{f1},
	\end{eqnarray*}
	for every $\A = \langle A, \S^{\A}, \leq^{\A} \rangle \in \str$, where $\P = (P_1,\ldots,P_r)$ and $P_i \subseteq A^{a_i}$ for every $i \in \{1,\ldots,r\}$. For the time being, suppose that
	\begin{eqnarray}
	\varphi(\x,\X) &=& \left( \bigwedge_{i=1}^n X_{\lambda(i)}(\x_i) \right) \wedge \varphi^{-}(\X,\y) \wedge \theta(\x) \wedge \beta(\x)
	\end{eqnarray}
	where $n$ is the number of times a non-negated variable in $\X$ is referred to, according to the function $\lambda:\{1,\ldots,n\}\to\{1,\ldots,r\}$, $\y$ is a $p$-tuple of variables in $\x$, $\varphi^{-}(\X,\y)$ is a conjunction of negated predicates in $\X$, $\theta(\x)$ defines a total order on a partition of $\x$, and $\beta(\x)$ is an FO-formula over $\L$ which mentions all variables in $\x$. Note that $\theta(\x)$ also mentions all variables in $\x$. We also assume that $(\x_1,\dots,\x_n,\y) = \x$. As an example, the following formula is of this form:
	\begin{multline*}
	\varphi(\x,\X) =  X_1(x_1,x_2) \wedge X_3(x_3) \wedge X_2(x_4,x_5) \wedge X_3(x_6) \wedge \neg X_1(x_7,x_8) \wedge \\ (x_1 < x_2 \wedge x_1 = x_3 \wedge x_1 = x_4 \wedge x_2 = x_8 \wedge x_2 = x_5 \wedge x_8 < x_6 \wedge x_6 = x_7 ) \wedge \\ \forall z\big( S_1(x_1,z,x_2) \wedge x_3 = x_3 \wedge x_4 = x_4 \wedge x_5 = x_5 \wedge x_6 = x_6 \wedge x_7 = x_7 \wedge x_8 = x_8 \big),
	\end{multline*}
	where $\x = (x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8)$ and $\X = (X_1,X_2,X_3)$. Here, $n = 4$, $\lambda(1) = 1$, $\lambda(2) = \lambda(4) = 3$ and $\lambda(3) = 2$, $\x_1 = (x_1,x_2)$, $\x_2 = (x_3)$, $\x_3 = (x_4,x_5)$, $\x_4 = (x_6)$ and $\y = (x_7,x_8)$. Moreover, $\varphi^{-}(\X,\y) = \neg X_1(x_7,x_8)$, $\theta(\x) = (x_1 < x_2 \wedge x_1 = x_3 \wedge x_1 = x_4 \wedge x_2 = x_8 \wedge x_2 = x_5 \wedge x_8 < x_6 \wedge x_6 = x_7 )$, which defines a total order on the partition of $\x$ $\{\{x_1,x_3,x_4\},\{x_2,x_5,x_8\},\{x_6,x_7\}\}$, and $\beta(\x) = \forall z\big( S_1(x_1,z,x_2) \wedge x_3 = x_3 \wedge x_4 = x_4 \wedge x_5 = x_5 \wedge x_6 = x_6 \wedge x_7 = x_7 \wedge x_8 = x_8 \big)$.
	
	Similarly to the previous proof, we would like to eliminate the {\em lexicographically smallest}\footnote{We consider the lexicographically smallest tuple of predicates as the one in which its predicates contain the lexicographically smallest tuples and do not contain any more tuples than those} tuple of predicates that satisfies the formula \eqref{f1}. Let $\u_i$ be a $a_{\lambda(i)}$-tuple of variables for every $i \in \{1,\dots,n\}$, and let $m = \sum_{i = 1}^n a_{\lambda(i)}$ be the number of variables of $(\x_1,\dots,\x_n)$. We now define
	\begin{multline*}
	\alpha_{\min}(\u_1,\dots,\u_n) = \exists\y\Big[ \alpha(\u_1,\dots,\u_n,\y)\wedge \\ \forall\v_1\cdots\forall\v_n\forall\w\Big(\big(\alpha(\v_1,\dots,\v_n,\w)\wedge\bigvee_{i=1}^n(\u_i\neq\v_i)\big)\to \varphi_{m,<}((\u_1,\dots,\u_n),(\v_1,\dots,\v_n))\Big)\Big],
	\end{multline*}
	where $\alpha(\x) = \theta(\x) \wedge \beta(\x)$. Note that $\alpha_{\min}$ is satisfied only by the lexicographically \linebreak smallest assignment $(\d_1,\dots,\d_n)$ to $(\x_1,\dots,\x_n)$ such that $\A\models\theta(\d_1,\dots,\d_n,\l)$ and $\A\models\beta(\d_1,\dots,\d_n,\l)$ for some $\l \in A^p$. Our new formula is
	\begin{multline}
	\varphi^\prime(\x,\X) = \left( \bigwedge_{i=1}^n X_{\lambda(i)}(\x_i) \right) \wedge \varphi^{-}(\X,\y) \wedge \theta(\x) \wedge \beta(\x)\wedge \\ \exists\u_1\cdots\exists\u_n\bigg[\alpha_{\min}(\u_1,\dots,\u_n) \wedge \bigg(\bigg(\bigvee_{i = 1}^{n}\neg X_{\lambda(i)}(\u_i) \bigg) \vee \bigvee_{i=1}^r \exists \v\Big( X_i(\v) \wedge \bigwedge_{j\in[1,n]:\: \lambda(j) = i} \v \neq \u_j\Big) \bigg) \bigg].
	\end{multline}
	We now show a result by which the main proof will follow.
	\begin{lemma} \label{first}
		$f_{\exists \x \: \varphi^\prime(\x,\X)} = f_{\exists \x \: \varphi(\x,\X)} \dotminus 1$.
	\end{lemma}
	\begin{proof}
		Let $\A \in \str$. Consider two cases: assume first that $\A\models\exists\x\,\varphi(\x,\R)$ for some assignment $\R$ to $\X$. Let $\d = (\d_1,\dots,\d_n,\ep)$ be the lexicographically smallest assignment to $\x$ for which $\A\models\alpha(\d)$, where $\d_i$ is the respective assignment to $\x_i$, for every $i\in\{1,\dots,n\}$, and $\ep$ is an assignment for $\y$. Consider now the tuple $\P = (P_1,\dots,P_r)$ where $P_i = \bigcup_{j\in[1,n]:\:\lambda(j)=i}\{\d_j\}$. We will show that this assignment to $\X$ is such that (a) $\A\models\exists\x\,\varphi(\x,\P),$ (b) $\A\not\models\exists\x\,\varphi^\prime(\x,\P)$ and (c) $\P$ is the only assignment that satisfies (a) and (b).
		\begin{enumerate}
			\item[(a)] By contradiction, suppose that $\A\not\models\exists\x\,\varphi(\x,\P)$. That is, there is no assignment $\s$ to $\x$ such that $\A\models\varphi(\s,\P).$ Since $\d$ is such that $\A\models \bigwedge_{i=1}^n P_{\lambda(i)}(\d_i)$ and $\A\models \alpha(\d)$, it follows that $\A\not\models\varphi^{-}(\P,\ep)$ (since $\alpha(\d)=\theta(\d)\wedge\beta(\d)$). Therefore, there is an $i\in\{1,\ldots,n\}$ such that $\neg P_{\lambda(i)}(\d_i)$ appears in $\varphi^{-}(\P,\ep)$. Then, there is an $a_{\lambda(i)}$-tuple $\z$ in $\y$ such that $\neg X_{\lambda(i)}(\z)$ appears in $\varphi^{-}(\X,\x)$. We know that either (1) $\theta(\x)\models \z = \x_i$, (2) $\theta(\x)\models \varphi_{<,a_i}(\z,\x_i)$ or (3) $\theta(\x)\models \varphi_{<,a_i}(\x_i,\z)$. Considering that (2) and (3) are not possible given that both $\z$ and $\x_i$ are assigned the value $\d_i$ and $\A\models\theta(\d)$, we have that $\theta(\x)\models \z = \x_i$. But if this is the case, then $X_{\lambda(i)}(\x_i), \neg X_{\lambda(i)}(\z)$ and $\z = \x_i$ are all logical consequences of $\varphi(\x,\X)$, which means $\varphi(\x,\X)$ is inconsistent. That is, there's no structure $\A^\prime\in\str$ such that $\A^\prime\models\exists\x\:\varphi(\x,\R^\prime)$ for any assignment $\R^\prime$ to $\X$. In particular, $\A\not\models\exists\x\,\varphi(\x,\R^\prime)$ for every possible assignment $\R^\prime$ to $\X$, which contradicts the initial assumption that $\A\models\exists\x\,\varphi(\x,\R)$ for some assignment $\R$ to $\X$.
			\item[(b)] Note that if $\A \models \alpha_{\min}(\c_1,\ldots,\c_n)$, then necessarily $\c_i = \d_i$ for $i\in\{1,\ldots,n\}.$ However, by the construction of $\P$, we see that 
			$$\A\not\models\bigvee_{i = 1}^{n}\neg P_{\lambda(i)}(\d_i) \text{ and that } \A\not\models\bigvee_{i=1}^r \exists \v\Big( P_i(\v) \wedge \bigwedge_{j\in[1,n]:\: \lambda(j) = i} \v \neq \d_j\Big).$$ Then, $\A\not\models\exists\x\,\varphi^\prime(\x,\P)$.
			\item[(c)] By contradiction, let $\P^\prime \neq \P$ be such that $\A\models\exists\x\,\varphi(\x,\P^\prime)$ and $\A\not\models\exists\x\,\varphi^\prime(\x,\P^\prime)$. We consider two cases: first, suppose that $\P^\prime$ is missing a tuple of $\P$. Let $i\in\{1,\ldots,n\}$ such that in $\d_i$ is not in $P^\prime_i$. Then $\A\models \neg P^\prime_i(\d_i)$, and so,$$\A\models \bigg(\bigvee_{i = 1}^{n}\neg X_{\lambda(i)}(\d_i) \bigg), $$ from which we conclude that $\A\models\exists\x\,\varphi^\prime(\x,\P^\prime)$. Second, suppose there is some predicate $\P^\prime_i$ in $\P^\prime$ which has a tuple that $P_i$ does not have. If this is the case, then $$\A\models\bigvee_{i=1}^r \exists \v\Big( P_i(\v) \wedge \bigwedge_{j\in[1,n]:\: \lambda(j) = i} \v \neq \u_j\Big),$$ so $\A\models\exists\x\,\varphi^\prime(\x,\P^\prime)$. On both cases, we have a contradiction.
		\end{enumerate}
		With this, we conclude that for every $\A\in\str$ such that $f_{\exists\x\,\varphi(\x,\X)}(\A)>0,$ we have that $f_{\exists\x\,\varphi^\prime(\x,\X)}(\A) = f_{\exists\x\,\varphi(\x,\X)}(\A)-1.$
		
		Second, assume that there is no assignment $\R$ to $\X$ such that $\A\models\exists\x\,\varphi(\x,\R)$. Let $\P$ be an arbitrary assignment to $\X$. Since $\A\not\models\exists\x\,\varphi(\x,\P)$, we see that $\A\not\models\exists\x\,(\varphi(\x,\P)\wedge\psi(\x,\P))$ for any formula $\psi(\x,\P)$. It follows that there is no assignment $\R$ to $\X$ such that $\A\models\exists\x\,\varphi^\prime(\x,\R)$. And so, for every $\A\in\str$ such that $f_{\exists\x\,\varphi(\x,\X)}(\A)=0,$ it holds that $f_{\exists\x\,\varphi^\prime(\x,\X)}(\A) = 0.$ We conclude that $f_{\exists\x\,\varphi^\prime(\x,\X)} = f_{\exists\x\,\varphi(\x,\X)}\dotminus 1,$ which was to be shown.
	\end{proof}
	We now continue with the general case, in which $\varphi(\x,\X)$ is an arbirtary extended quantifier-free $\L$-formula. By using a standard DNF transformation algorithm and considering FO-formulas over $\L$ as literals, we can find formulas $\gamma_i(\x,\X)$ with $i\in\{1,\ldots,\ell\}$ such that
	\begin{eqnarray*}
		\varphi(\x,\X) &\equiv& \gamma_1(\x,\X) \vee \gamma_2(\x,\X) \vee \dots  \vee \gamma_{\ell}(\x,\X),
	\end{eqnarray*}
	where, for every $i\in\{1,\ldots,\ell\}$, 
	\begin{eqnarray*}
		\gamma_i(\x,\X) &=& \left( \bigwedge_{j=1}^{n_i} X_{\lambda_i(j)}(\x_{i,j}) \right) \wedge \gamma^{-}_i(\X,\y_i)  \wedge \delta_i(\x).
	\end{eqnarray*}
	The function $\lambda_i$ is defined analogously to $\lambda$ of the first part of the proof. The tuple $\x_{i,j}$ has $a_{\lambda_i(j)}$ variables for $j\in\{1,\ldots,n_i\}$, $\y_i$ has $p_i$ variables and are such that $(\x_{i,1},\ldots,\x_{i,n_i},\y_i) = \x.$ The formulas $\gamma^{-}_i(\X,\y_i)$, $\delta_i(\x)$ are defined analogously to $\varphi^{-}(\X,\y)$ and $\beta(\x)\,$\footnote[2]{Note that $\delta_i(\x)$ can include subformulas of the form $(\u = \u)$.} respectively (see \eqref{f1}). Let $g$ be a function that counts the number of possible orders over partitions on a $d$-tuple of variables. Let the formulas $\theta^i(\x)$ for $i\in\{1,\ldots,g(d)\}$ represent each of these orders over $\x$. Note that for every formula $\eta(\x)$,
	\begin{eqnarray*}
		\exists\x\:\eta(\x) &\equiv& \exists\x(\eta(\x)\wedge\theta^1(\x)) \vee \cdots \vee \exists\x(\eta(\x)\wedge\theta^{g(d)}(\x)).
	\end{eqnarray*}
	We define the following formulas $\xi_i(\x,\X)$, for $i\in\{1,\ldots,m\}$ where $m = \ell \cdot g(d)$, as follows: 
	\begin{eqnarray*}
		\xi_1(\x,\X) &=& \gamma_1(\x,\X) \wedge \theta^1(\x), \\
		& \vdots & \\
		\xi_{g(d)}(\x,\X) &=& \gamma_1(\x,\X) \wedge \theta^{g(d)}(\x), \\
		\xi_{g(d)+1}(\x,\X) &=& \gamma_2(\x,\X) \wedge \theta^1(\x), \\
		& \vdots & \\
		\xi_{2\cdot g(d)}(\x,\X) &=& \gamma_2(\x,\X) \wedge \theta^{g(d)}(\x), \\
		& \vdots & \\
		\xi_{(\ell-1) g(d)+1}(\x,\X) &=& \gamma_{\ell}(\x,\X) \wedge \theta^1(\x), \\
		& \vdots & \\
		\xi_{\ell \cdot g(d)}(\x,\X) &=& \gamma_{\ell}(\x,\X) \wedge \theta^{g(d)}(\x).
	\end{eqnarray*}
	Having every disjunct with a total order allows us to eliminate the ones that are unsatisfiable for every $\L$-structure $\A$, that is, each $i\in\{1,\ldots,m\}$ such that for every assignment $\s$ to $\x,$ $f_{\xi_i(\s,\X)}(\A) = 0,$ for every $\A\in\str.$ Let $k$ be the number of disjuncts that are left after eliminating the unsatisfiable disjuncts. We use an injective\footnote[3]{We need this function to be injective because this way we can assure each one of the $k$ satisfiable disjuncts to be represented} function $\rho:\{1,\ldots,k\}\to\{1,\ldots,m\}$ such that $\varphi_i(\x,\X) = \xi_{\rho(i)}(\x,\X)$ is satisfiable, for every $i\in\{1,\ldots,k\}.$
	
	We can conclude that
	\begin{eqnarray*}
		\varphi(\x,\X) &\equiv& \varphi_1(\x,\X) \vee \varphi_2(\x,\X) \vee \dots  \vee \varphi_k(\x,\X),
	\end{eqnarray*}
	and for every $i\in\{1,\ldots,k\}$,
	\begin{eqnarray*}
		\varphi_i(\x,\X) &=& \left( \bigwedge_{j=1}^{n_i} X_{\lambda_i(j)}(\x_{i,j}) \right) \wedge \varphi^{-}_i(\X,\y_i) \wedge \theta_i(\x) \wedge \beta_i(\x),
	\end{eqnarray*}
	where $n_i$ is the number of times a non-negated variable in $\X$ is referred to, according to the function $\lambda_i:\{1,\ldots,n_i\}\to\{1,\ldots,r\}$, $\y_i$ is a $p_i$-tuple of variables in $\x$, $\varphi_i^{-}(\X,\y_i)$ is a conjunction of negated predicates in $\X$, $\theta_i(\x)$ defines a total order on a partition of $\x$, and $\beta_i(\x)$ is an FO-formula over $\L$ which mentions all variables in $\x$. Let $\alpha_i(\x) = \theta_i(\x)\wedge\beta_i(\x).$
	
	%% CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM
	%% CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM CLAIM
	
	\begin{claim} \label{alpha}
		Let $\A\in\str$ and $i\in\{1,\ldots,k\}$. For every assignment $\s$ to $\x$ such that $\A\models\alpha_i(\s)$, it holds that $f_{\varphi_i(\s,\X)}(\A) > 0.$
	\end{claim}
	\begin{proof}
		Let $\s = (\s_1,\ldots,\s_{n_i},\t)$ such that $\A\models\alpha_i(\s)$, and let $\P = (\P_1,\ldots,\P_r)$ where $P_i = \bigcup_{j\in[1,n_i]:\:\lambda(j)=i}\{s_i\}$. We will show that $\A\models\varphi_i(\s,\P)$. By contradiction, suppose that $\A\not\models\exists\x\,\varphi_i(\x,\P)$. That is, there is no assignment $\e$ to $\x$ such that $\A\models\varphi(\e,\P).$ Following the same proof as in case (a) of Lemma \ref{first}, we conclude that $\varphi_i(\x,\P)$ is inconsistent. However, as we mentioned previously, all of such disjuncts have been eliminated, which leads to a contradiction.
	\end{proof}
	
	Our plan now is to exclude the lexicographically smallest assignment $\P$ such that $\A\models\exists\x\:\varphi_1(\x,\P)$, and if there is no such $\P$, exclude the lexicographically smallest $\Q$ such that $\A\models\exists\x\:\varphi_2(\x,\Q)$, and so on. As we already know how to exclude that assignment in the first disjunct, we will now deal with the next disjuncts. Similarly to the first part of the proof, for each $i\in\{1,\ldots,k\}$ let $m_i = \sum_{j = 1}^{n_i} a_{\lambda_i(j)}$ and let
	\begin{multline*}
	\alpha^i_{\min}(\u_1,\dots,\u_{n_i}) = \exists\y\Big[ \alpha_i(\u_1,\dots,\u_{n_i},\y)\wedge \\ \forall\v_1\cdots\forall\v_{n_i}\forall\w\Big(\big(\alpha_i(\v_1,\dots,\v_{n_i},\w)\wedge\bigvee_{j=1}^{n_i}(\u_j\neq\v_j)\big)\to \varphi_{m_i,<}((\u_1,\dots,\u_{n_i}),(\v_1,\dots,\v_{n_i}))\Big)\Big],
	\end{multline*}
	where $\u_j$ and $\v_j,$ have $a_{\lambda_i(j)}$ variables for $j\in\{1,\ldots,n_i\}$, and $\w$ has $p_i$ variables. Also, let
	\begin{multline*}
	\psi_i(\X) = \forall\x\:\neg\alpha_i(\x) \vee \exists\u_1\cdots\exists\u_{n_i}\bigg[\alpha^i_{\min}(\u_1,\dots,\u_{n_i}) \\ \wedge \bigg(\bigg(\bigvee_{j = 1}^{n_i}\neg X_{\lambda_i(j)}(\u_i) \bigg) \vee \bigvee_{j=1}^r \exists \v\Big( X_j(\v) \wedge \bigwedge_{\ell\in[1,n_i]: \lambda_i(\ell) = j} \v \neq \u_\ell\Big) \bigg) \bigg].
	\end{multline*}
	Note that $\psi_i(\X)$ excludes only the lexicographically smallest tuple of predicates $\P$ such that $\A\models\exists\x\:\varphi_i(\P,\x),$ if there is at least one. In other words, every assignment $\P^\prime \neq \P$ is such that $\A\models\psi_i(\P^\prime).$ Our new formula $\varphi_i^\prime(\x,\X)$ is defined as follows:
	\begin{multline}
	\varphi_i^\prime(\x,\X) = \varphi_i(\x,\X) \wedge \psi_1(\X) \wedge (\exists\v\:\alpha_1(\v)\vee\psi_2(\X)) \wedge \cdots \wedge \\ (\exists\v\:\alpha_1(\v)\vee\cdots\vee\exists\v\:\alpha_{i-1}(\v)\vee\psi_i(\X)).
	\end{multline}
	Let $\varphi^\prime(\x,\X) = \varphi_1^\prime(\x,\X)\vee\cdots\vee\varphi_k^\prime(\x,\X).$ We will now show that $f_{\exists\x\varphi^\prime(\x,\X)} = f_{\exists\x\varphi(\x,\X)}\dotminus 1.$ Assume that $\A\in\str$. Suppose first that there is at least one assignment $\R$ to $\X$ such that $\A\models\exists\x\:\varphi(\x,\R).$ Let $q$ be the least $i\in\{1,\ldots,k\}$ such that there exists at least one assignment $\R^\prime$ to $\X$ for which $\A\models\exists\x\:\varphi_i(\x,\R^\prime).$ Let $\d = (\d_1,\dots,\d_{n_q},\ep)$ be the lexicographically smallest assignment to $\x$ for which $\A\models\alpha_q(\d)$, where $\d_i$ is the corresponding assignment to $\x_i$, for every $i\in\{1,\dots,n_q\}$, and $\ep$ is an assignment for $\y$. Consider now the tuple $\P = (P_1,\dots,P_r)$ where $P_i = \bigcup_{j:\lambda_q(j)=i,j\in[1,n_q]}\{\d_j\}$. As we did in Lemma \ref{first} we will show that $\P$ is such that (a) $\A\models\exists\x\:\varphi(\x,\P),$ (b) $\A\not\models\exists\x\:\varphi^\prime(\x,\P),$ and (c) $\P$ is the only assignment to $\X$ that satisfies both (a) and (b)
	\begin{enumerate}
		\item[(a)] As we showed in part (a) of Lemma \ref{first}, if there is at least one assignment $\R$ to $\X$ such that $\A\models\exists\x\:\varphi_q(\x,\R)$, then $\A\models\exists\x\:\varphi_q(\x,\P)$ for this particular $\P$. However, as we showed in Claim \ref{alpha}, if there is an assignment $\s$ to $\x$ such that $\A\models\alpha_q(\s)$, then there {\em is} such an assignment to $\X$. The assignment $\d$ to $\x$ satisfies that $\A\models\alpha_q(\d)$, so it holds that $\A\models\exists\x\:\varphi_q(\x,\P)$. It immediately follows that $\A\models\exists\x\:\varphi(\x,\P).$
		
		\item[(b)] We will show that $\A\not\models\exists\x\:\varphi^\prime_i(\x,\P)$ for (1) $i\in\{1,\ldots,q-1\}$, and (2) $i\in\{q,\ldots,k\}$. (1) By the choice of $q$, it holds that $\A\not\models\exists\x\:\varphi^\prime_i(\x,\P)$ for every $i\in\{1,\ldots,q-1\}$ since there is no possible assignment to $\X$ for any of their sub-formulas $\varphi_i(\x,\X)$. (2) We can use the proof in Lemma \ref{first} to see that $\A\not\models\psi_q(\P).$ For each $i\in\{q,\ldots,k\}$, the sub-formula 
		$$ \zeta_q(\X) =  (\exists\v\:\alpha_1(\v)\vee\cdots\vee\exists\v\:\alpha_{q-1}(\v)\vee\psi_q(\X)) $$ 
		appears as a conjunct in $\varphi^\prime_i(\x,\X)$. However, by the choice of $q$, there is no $i\in\{1,\ldots,q-1\}$ such that $\A\models\exists\v\:\varphi_i(\v,\P)$, and also $\A\not\models\psi_q(\P)$. It follows that $\A\not\models\zeta_q(\P)$,  so $\A\not\models\exists\x\:\varphi^\prime_i(\x,\P)$. And so, we conclude that $\A\not\models\exists\x\:\varphi^\prime(\x,\P).$
		
		\item[(c)] Suppose there is an assignment $\P^\prime \neq \P$ to $\X$ that satisfies both (a) and (b). As we deduce from the part (c) of Lemma \ref{first}, $\P$ is the only assignment to $\X$ such that $\A\not\models\:\psi_q(\P)$, so necessarily $\A\models\:\psi_q(\P^\prime)$. Since $\P^\prime$ assigned to $\X$ satisfies (a), then $\A\models\exists\x\:\varphi(\x,\P^\prime).$ By the choice of $q,$ every $i\in\{1,\ldots,q-1\}$ is such that $\A\models\forall\x\:\neg\alpha_i(\x)$, so $\A\models\psi_i(\P^\prime)$ for each $i$. But as we mentioned, also $\A\models\:\psi_q(\P^\prime),$ which means that $\A\models\exists\x\:\varphi^\prime_q(\x,\P^\prime),$ and so, $\A\models\exists\x\:\varphi^\prime(\x,\P^\prime),$ which leads to a contradiction.
	\end{enumerate}
	
	With this, we conclude that for every $\A\in\str$ such that $f_{\exists\x\,\varphi(\x,\X)}(\A)>0$, we have that $f_{\exists\x\,\varphi^\prime(\x,\X)}(\A) = f_{\exists\x\,\varphi(\x,\X)}(\A)-1.$
	
	Second, assume that there is no assignment $\R$ to $\X$ such that $\A\models\exists\x\,\varphi_i(\x,\R)$ for any $i\in\{1,\ldots,k\}$. Let $\P$ be an arbitrary assignment to $\X$. Since $\A\not\models\exists\x\,\varphi_i(\x,\P)$, for any $i,$ we see that $\A\not\models\exists\x\,(\varphi(\x,\P)\wedge\chi(\x,\P))$ for any formula $\chi(\x,\P)$. It follows that there is no assignment $\R$ to $\X$ such that $\A\models\exists\x\,\varphi^\prime_i(\x,\R),$ for any $i\in\{1,\ldots,k\}$. And so, for every $\A\in\str$ such that $f_{\exists\x\,\varphi(\x,\X)}(\A)=0,$ we have that $f_{\exists\x\,\varphi^\prime(\x,\X)}(\A) = 0.$ Hence, from the results in the previous paragraph, if $f^\prime = f_{\exists\x\,\varphi^\prime(\x,\X)}$, we have that $f^\prime = f\dotminus 1\in\E{1}$ 
	
	\item Let $f \in \E{1}$ be defined by an extended quantifier free $\L$-formula $\varphi(\x,\X,\z)$, where $\x = (x_1,\dots,x_d), \X = (X_1,\dots,X_r)$ and $\z = (z_1,\dots,z_p)$. That is,
	\begin{eqnarray*}
		f(\A) &=& \mid \{ \langle\P,\e\rangle \mid \A \models \exists \x \ \varphi(\x,\P,\e) \} \mid,
	\end{eqnarray*}
	for every $\A = \langle A, \S^{\A}, \leq^{\A} \rangle \in \str$, where $\P = (P_1,\ldots,P_r)$, $P_i \subseteq A^{a_i}$ for every $i \in \{1,\ldots,r\}$ and $\e \in A^p$. In order to prove that $f\dotminus 1\in\E{1}$, we define the formulas $\varphi_i(\x,\X,\z)$ for $i\in\{1,\ldots,k\}$ in the same way as case 2, where
	\begin{eqnarray*}
		\varphi(\x,\X,\z) \equiv \varphi_1(\x,\X,\z) \vee \cdots \vee \varphi_k(\x,\X,\z),
	\end{eqnarray*}
	and
	\begin{eqnarray*}
		\varphi_i(\x,\X,\z) &=& \left( \bigwedge_{j=1}^{n_i} X_{\lambda_i(j)}(\x_{i,j},\z_{i,j}) \right) \wedge \varphi^{-}_i(\X,\y_i,\w_i) \wedge \theta_i(\x,\z) \wedge \beta_i(\x,\z),
	\end{eqnarray*}
	where $n_i$ is the number of times a non-negated variable in $\X$ is referred to, according to the function $\lambda_i:\{1,\ldots,n_i\}\to\{1,\ldots,r\}$, the tuple $\x_{i,j}$ has $b_{\lambda_i(j)}$ variables and the tuple $\z_{i,j}$ has $c_{\lambda_i(j)}$ for $j\in\{1,\ldots,n_i\}$ (note that $b_{\ell} + c_{\ell} = a_{\ell}$ for $\ell\in\{1,\ldots,r\}$), $\y_i$ has $p_i$ variables, and $\w_i$ has $q_i$ variables. Furthermore, we have that $(\x_{i,1},\ldots,\x_{i,n_i},\y) = \x$ and $(\z_{i,1},\ldots,\z_{i,n_i},\w_i) = \z.$ The formula $\theta(\x,\z)$ defines a total order, analogously to case 2. The formulas $\varphi^{-}_i(\X,\y_i,\w_i)$, $\beta_i(\x,\z)$, are also defined analogously.
	
	In this case, we mix both the strategies in cases 1 and 2. That is, we are going to {\em isolate} the lexicographically smallest tuple of predicates that satisfies the first satisfiable disjunct, and then {\em exclude} the lexicographically smallest tuple that satisfies the isolated disjunct.
	
	Let $m_i = \sum_{j = 1}^{n_i} a_{\lambda_i(j)}$ and
	\begin{multline*}
	\alpha^i_{\min}(\x_1,\dots,\x_{n_i},\z_1,\dots,\z_{n_i}) = \exists\y\exists\w\Big[ \alpha_i(\x_1,\dots,\x_{n_i},\y,\z_1,\dots,\z_{n_i},\w)\wedge \\ \forall\u_1\cdots\forall\u_{n_i}\forall\s\forall\v_1\cdots\forall\v_{n_i}\forall\t\Big(\big(\alpha_i(\u_1,\dots,\u_{n_i},\s,\v_1,\dots,\v_{n_i},\t)\wedge\bigvee_{j=1}^{n_i}(\x_j\neq\u_j \vee \z_j\neq\v_j)\big)\to \\ \varphi_{m_i,<}((\x_1,\dots,\x_{n_i},\z_1,\dots,\z_{n_i}),(\u_1,\dots,\u_{n_i},\v_1,\dots,\v_{n_i}))\Big)\Big],
	\end{multline*}
	and let
	\begin{multline*}
	\psi_i(\X,\z) = \forall\x\forall\v\:\neg\alpha_i(\x,\v) \vee \exists\u_1\cdots\exists\u_{n_i}\exists\w_1\cdots\exists\w_{n_i}\bigg[\alpha^i_{\min}(\u_1,\dots,\u_{n_i},\w_1,\dots,\w_{n_i}) \\ \wedge \bigg(\bigg(\bigvee_{j = 1}^{n_i}\neg X_{\lambda_i(j)}(\u_i,\w_i) \bigg) \vee \bigvee_{j=1}^r \exists \s\exists \t\Big( X_j(\s,\t) \wedge \bigwedge_{\ell\in[1,n_i]: \lambda_i(\ell) = j} \s \neq \u_\ell \vee \t \neq \w_\ell\Big) \bigg) \bigg] \vee \\ \exists\w(\exists\u\:\varphi(\u,\X,\w) \wedge \varphi_{p,<}(\w,\z)).
	\end{multline*}
	Let $\P$ and $\e$ be assignments to $\X$ and $\z$. Note that $\psi_i(\X,\z)$ excludes $\P$ and $\e$ only if $\P$ is the {\em lexicographically smallest} tuple of predicates (Same as case 2) such that $\A\models\exists\x\:\varphi_i(\x,\P,\d)$, for some assignment $\d$ to $\z$, and $\e$ is the lexicographically smallest assignment to $\z$ such that $\A\models\exists\x\:\varphi_i(\x,\P,\e).$ We define $\varphi_i^\prime(\x,\X,\z)$ in the same way as case 2:
	\begin{multline*}
	\varphi_i^\prime(\x,\X,\z) = \varphi_i(\x,\X,\z) \wedge \psi_1(\X,\z) \wedge (\exists\u\exists\v\:\alpha_1(\u,\v)\vee\psi_2(\X,\z)) \wedge \cdots \wedge \\ (\exists\u\exists\v\:\alpha_1(\u,\v)\vee\cdots\vee\exists\u\exists\v\:\alpha_{i-1}(\u,\v)\vee\psi_i(\X,\z)).
	\end{multline*}
	Finally, let $\varphi^\prime(\x,\X,\z) = \bigvee_{i = 1}^k \varphi_i^\prime(\x,\X,\z)$.
	
	Let $q$ be the least $i\in\{1,\ldots,k\}$ such that $\A\models\exists\x\:\varphi_i(\x,\R,\d)$ for some assignment $R$ to $\X$ and some assignment $\d$ to $\z$. Let $\P$ be the lexicographically smallest tuple of predicates such that $\A\models\exists\x\:\varphi_q(\x,\P,\d^\prime)$ for some assignment $\d^\prime$ to $\z$. Let $\e$ be the lexicographically smallest assignment to $\z$ such that $\A\models\exists\x\:\varphi_q(\x,\P,\e).$ This formula is such that (a) $\A\models\exists\x\:\varphi(\x,\P,\e)$, (b) $\A\not\models\exists\x\:\varphi^\prime(\x,\P,\e)$ and $\P$ and $\e$ are the only assignments that satisfy (a) and (b). The proof of this is analogous to case 2. Therefore, we conclude that $f_{\exists\x\,\varphi^\prime(\x,\X,\z)} = f_{\exists\x\,\varphi(\x,\X,\z)}\dotminus 1.$
\end{enumerate}
		
\textbf{Proof of Theorem \ref{dnf-pars}}

Let $f$ be an arbitrary function in $\E{1}$ and let $f_{\textsc{\#DNF}}$ be the function that defines {\sc \#DNF}. We will now show a function $h:\str\to \textsc{Struct}[\L_{\textsc{DNF}}]$, where $\L_{\textsc{DNF}} = \{N,P\}$, such that for every $\A\in\str$, it holds that $f(\A) = f_{\textsc{\#DNF}}(h(\A))$, and which can be computed in polynomial time. For every DNF formula $\Phi$ we define $\A_{\Phi} \in \textsc{Struct}[\L_{\textsc{DNF}}]$ as stated in \ref{dnfdef}. Let $\psi$ be such that $f = f_{\psi(\X,\z)}$. We separate the proof in three cases:
\begin{enumerate}
	\item $\X = ()$. Let $\psi(\z) = \exists \x\,\varphi(\x,\z)$ where $\x = (x_1,\ldots,x_c)$ and $\z = (z_1,\ldots,z_d)$. Given a structure $\A = \langle A, \S^{\A}, \leq^{\A} \rangle\in\str$, we generate a propositional formula $\Phi = h(\A)$. First we notice that this case is trivial since we can calculate this function in polynomial time, by checking for each $\e\in A^d$ if $\A\models\exists\x\,\varphi(\x,\e)$. Let $n$ be the number of such assignments to $\z$. Let $\p$ be an $n$-tuple of propositional variables where $\p = (p_1,\ldots,p_n)$. The DNF formula we generate is
	\[
	\Phi = \bigvee_{i = 1}^n \neg p_1 \wedge \cdots \wedge \neg p_{i-1} \wedge p_i \wedge \neg p_{i+1} \wedge \cdots \wedge \neg p_n
	\]
	which has exactly $n$ possible assignments. Finally, we return $h(\A) = \A_{\Phi}$.
	
	\item $\z = ()$. Let $\psi(\X) = \exists \x\,\varphi(\x,\X)$, where $\x = (x_1,\ldots,x_c)$ and $\X = (X_1,\ldots,X_r)$. Given a structure $\A = \langle A, \S^{\A}, \leq^{\A} \rangle\in\str$, we generate a DNF-formula $\Phi = h(\A)$ as follows. First, we convert $\varphi(\x,\X)$ into an equivalent DNF formula $\bigvee_{i = 1}^k \varphi_{i}(\x,\X)$. Let each $\varphi_{i}(\x,\X)$ be of the form
	\[
	\varphi_{i}(\x,\X) = X_{\pi_i(1)}(\x^{\pi}_{i,1}) \wedge \cdots \wedge X_{\pi_i(m_i)}(\x^{\pi}_{i,m_i}) \wedge \neg X_{\nu_i(1)}(\x^{\nu}_{i,1}) \wedge \cdots \wedge \neg X_{\nu_i(n_i)}(\x^{\nu}_{i,n_i}) \wedge \alpha_i(\x),
	\]
	where $\pi_i:\{1,\ldots,n_i\}\to\{1,\ldots,r\}$, $\nu_i:\{1,\ldots,m_i\}\to\{1,\ldots,r\}$, $\x^{\pi}_{i,j}$ ($\x^{\nu}_{i,j}$) is the rearrangement of $\x$ in the $j$-th positive (negative) second order variable mentioned in $\varphi_i$, and $\alpha(\x)$ is a FO formula. We also define the tuple $\a^{\pi}_{i,j}$ ($\a^{\nu}_{i,j}$) as $\a$ rearranged in the same way as $\x^{\pi}_{i,j}$ ($\x^{\nu}_{i,j}$), for each $\a\in A^c$.
	
	We generate a propositional variable $p^{\ell}_{\a}$ for each $\a\in A^{c_{\ell}}$, and for each $\ell\in\{1,\ldots,r\}$, which will indicate if the tuple $\a$ is in the assignment to $X_{\ell}$. Let $\p$ be the tuple of all such variables.
	
	Then, let $\Gamma_i = \{\a\in A^c\mid \A\models\alpha_i(\a)\}$. There is exactly $\vert A \vert^c$ tuples to check, and each of those checks can be done in polynomial time, so this set can also be generated in polynomial time.
	
	Finally, for each $\varphi_i(\x,\X)$ the DNF formula we generate is
	\[
	\Phi_i = \bigvee_{\a\in\Gamma_i} p^{\pi_i(1)}_{\a^{\pi}_{i,1}} \wedge \cdots \wedge p^{\pi_i(m_i)}_{\a^{\pi}_{i,m_i}} \wedge \neg p^{\nu_i(1)}_{\a^{\nu}_{i,1}} \wedge \cdots \wedge \neg p^{\pi_i(n_i)}_{\a^{\nu}_{i,n_i}}.
	\]
	and $\Phi = \bigvee_{i = 1}^k \Phi_i \vee \bigvee_{p\in\p} (p\wedge\neg p)$. Finally, we return $h(\A) = \A_{\Phi}$.
	
	As an example, let $\psi^{*}(X_1,X_2) = \exists x \exists y\, (X_1(x) \wedge X_2(y,x) \wedge \neg X_1(y) \wedge x < y \wedge \neg\exists z\,(x<z\wedge z<y))$. We will compute $h(\B)$, where $\B = \langle \{1,2,3\}, < \rangle$, and we have that $1 < 2 < 3$. We generate the tuple of variables $\p = (p^1_1,p^1_2,p^1_3) \cup (p^2_{(i,j)})$ for $(i,j)\in \{1,2,3\}\times\{1,2,3\}$. Note that in this procedure we will only have one set $\Gamma_1 = \{(1,2),(2,3)\}$. And so, the DNF formula we generate is 
	\begin{multline*}
	\Phi^{*} = (p^1_1\wedge p^2_{(2,1)} \wedge \neg p^1_2)\vee(p^1_2\wedge p^2_{(3,2)} \wedge \neg p^1_3)\, \vee \\ (p^1_1 \wedge \neg p^1_1) \vee(p^1_2 \wedge \neg p^1_2) \vee (p^1_3\wedge \neg p^1_3) \vee \bigvee_{i,j\in\{1,2,3\}}(p^2_{(i,j)}\wedge\neg p^2_{(i,j)})
	\end{multline*}
	
	Note that for each assignment $\P$ to $\X$ such that $\A\models\exists\x\,\varphi(\x,\P)$ there is a corresponding assignment $\sigma$ to $\p$ where $\sigma(p^{\ell}_{\a}) = 1$ if and only if $\a\in P_{\ell}$. We can conclude that $f(\A) = f_{\textsc{DNF}}(\Phi)$.
	
	\item Let $\psi = \exists \x\,\varphi(\x,\X,\z)$, where $\x = (x_1,\ldots,x_c)$, $\z = (z_1,\ldots,z_d)$, $\X = (X_1,\ldots,X_r)$ and each $X_{\ell}$ has arity $c_{\ell}$. Given a structure $\A = \langle A, \S^{\A}, \leq^{\A} \rangle\in\str$ we generate a DNF-formula $\Phi = h(\A)$ as follows. As in the previous case, we convert $\varphi(\x,\X,\z)$ into an equivalent DNF formula $\bigvee_{i = 1}^k \varphi_{i}(\x,\X,\z)$. Let each $\varphi_{i}(\x,\X,\z)$ be of the form
	\[
	\varphi_{i}(\x,\X,\z) = X_{\pi_i(1)}(\y^{\pi}_{i,1}) \wedge \cdots \wedge X_{\pi_i(m_i)}(\y^{\pi}_{i,m_i}) \wedge \neg X_{\nu_i(1)}(\y^{\nu}_{i,1}) \wedge \cdots \wedge \neg X_{\nu_i(n_i)}(\y^{\nu}_{i,n_i}) \wedge \alpha_i(\x,\z),
	\]
	where $\pi_i:\{1,\ldots,n_i\}\to\{1,\ldots,r\}$, $\nu_i:\{1,\ldots,m_i\}\to\{1,\ldots,r\}$, $\y^{\pi}_{i,j}$ ($\y^{\nu}_{i,j}$) is the rearrangement of $(\x,\z)$ in the $j$-th positive (negative) second order variable mentioned in $\varphi_i$, and $\alpha(\x,\z)$ is a FO formula. We also define the tuple $(\a,\e)^{\pi}_{i,j}$ ($(\a,\e)^{\nu}_{i,j}$) as $\a$ rearranged in the same way as $\y^{\pi}_{i,j}$ ($\y^{\nu}_{i,j}$), for each $(\a,\e)\in A^{c+d}$.
	
	We generate a propositional variable $p^{\e}_{\ell,\b}$ for each $\e\in A^d$, for each $\ell\in\{1,\ldots,r\}$, and for each $\b\in A^{c_{\ell}}$. This variable will be true if there is an assignation to $\P$ such that $\b\in P_{\ell}$ and $\A\models\psi(\P,\e)$. Let $\p$ be the tuple of all such variables. We also generate a set $T = \{t_1,\ldots,t_{L}\}$ where $L = \lceil \log\vert A^d\vert \rceil$, and an arbitrary injective function $\beta:A^d \to \{0,1\}^L$ where $\beta(\e) = (b^{\e}_1,\ldots,b^{\e}_L)$ for each $\e\in A^d$. Also, let $\rho_{\ell}$ be such that $\rho_{\ell}(\x,\z) = \y_{\ell}$.
	
	For each $\e\in A^d$, we follow the following procedure. For each $\varphi_i(\x,\X)$, we consider the set $\Gamma^{\e}_i = \{\a\in A^c\mid \A\models\alpha(\a,\e)\}$, and so, the DNF formula we generate is
	\[
	\Phi^{\e}_i = \bigvee_{\a\in\Gamma_i} p^{\e}_{\pi_i(1),(\a,\e)^{\pi}_{i,1}} \wedge \cdots \wedge p^{\e}_{\pi_i(m_i),(\a,\e)^{\pi}_{i,m_i}} \wedge \neg p^{\e}_{\nu_i(1),(\a,\e)^{\nu}_{i,1}} \wedge \cdots \wedge \neg p^{\e}_{\pi_i(n_i),(\a,\e)^{\nu}_{i,n_i}} \wedge \gamma_{\e} \wedge \theta_{\e},
	\]
	where $\gamma_{\e}$ is defined as
	\[
	\gamma_{\e} = \bigwedge_{\e'\in A^d\setminus\{\e\}} \bigwedge_{\ell = 1}^r \bigwedge_{\b\,\in A^{c_{\ell}}} p_{\ell,\b}^{\e'},
	\]
	and $\theta_{\e}$ is defined as
	\[
	\theta_{\e} = \bigwedge_{i\in[1,L]:\,b^{\e}_i = 0} \neg t_i\  \wedge \bigwedge_{i\in[1,L]:\,b^{\e}_i = 1} t_i.
	\]
	Finally,$\Phi = \bigvee_{\e\in A^d} \bigvee_{i = 1}^k \Phi_i^{\e} \vee \bigvee_{p\in\p} (p\wedge\neg p)$, and we return $f(\A) = \A_{\Phi}$.
	
	As an example, let $\psi^{*}(X_1,X_2,z) = \exists x\, (X_1(x) \wedge X_2(z) \wedge \neg X_1(z) \wedge x < z)$. We will compute $h(\B)$, where $\B = \langle \{1,2,3\}, < \rangle$, and we have that $1 < 2 < 3$. We generate the tuple of variables $\p = (p^e_{1,1},p^e_{1,2},p^e_{1,3},p^e_{2,1},p^e_{2,2},p^e_{2,3})$, for $e\in \{1,2,3\}$. Here, we consider $L = 2$, $T = \{t_1,t_2\}$, and $\beta$ defined as $\beta(1) = (0,0)$, $\beta(2) = (0,1)$ and $\beta(3) = (1,0)$. In this procedure we generate the sets $\Gamma^1_1 = \emptyset$, $\Gamma^2_1 = \{1\}$, $\Gamma^3_1 = \{1,2\}$. Now we generate $\gamma_e$ for $e\in\{1,2,3\}$,
	\[
	\gamma_e = \bigwedge_{d\in\{1,2,3\}\setminus\{e\}} p^d_{1,1} \wedge p^d_{1,2} \wedge p^d_{1,3} \wedge p^d_{2,1} \wedge p^d_{2,2} \wedge p^d_{2,3},
	\]
	and $\theta_e$ for $e\in\{1,2,3\}$,
	\begin{align*}
	\theta_1 &= \neg t_1 \wedge \neg t_2,\\
	\theta_2 &= \neg t_1 \wedge t_2,\\
	\theta_3 &= t_1 \wedge \neg t_2.		
	\end{align*}
	Then, we generate the formulas $\Phi^e_1$, for $e\in\{1,2,3\}$,
	\begin{align*}
	\Phi^1_1 &= \square\\
	\Phi^2_1 &= p^2_{1,1} \wedge p^2_{2,2} \wedge \neg p^2_{1,2} \wedge \gamma_2 \wedge \theta_2,\\
	\Phi^3_1 &= (p^3_{1,1} \wedge p^3_{2,3} \wedge \neg p^3_{1,3} \wedge \gamma_3 \wedge \theta_3) \vee (p^3_{1,2} \wedge p^3_{2,3} \wedge \neg p^3_{1,3} \wedge \gamma_3 \wedge \theta_3),
	\end{align*}
	and so, the DNF formula we generate is
	\begin{multline*}
	\Phi = (p^2_{1,1} \wedge p^2_{2,2} \wedge \neg p^2_{1,2} \wedge \gamma_2 \wedge \theta_2) \vee (p^3_{1,1} \wedge p^3_{2,3} \wedge \neg p^3_{1,3} \wedge \gamma_3 \wedge \theta_3) \vee (p^3_{1,2} \wedge p^3_{2,3} \wedge \neg p^3_{1,3} \wedge \gamma_3 \wedge \theta_3) \vee \\ \bigvee_{e\in\{1,2,3\}}[(p^e_{1,1}\wedge\neg p^e_{1,1})\vee
	(p^e_{1,2}\wedge\neg p^e_{1,2})\vee
	(p^e_{1,3}\wedge\neg p^e_{1,3})\vee
	(p^e_{2,1}\wedge\neg p^e_{2,1})\vee
	(p^e_{2,2}\wedge\neg p^e_{2,2})\vee
	(p^e_{2,3}\wedge\neg p^e_{2,3})].
	\end{multline*}
	To demonstrate that our reduction is correct, we will show a function $g:\{\langle\P,\e\rangle \mid \A \models \exists\x\,\varphi(\x,\P,\e)\} \to \{\sigma \mid \sigma(\Phi) = 1\}$ and then prove that it is a bijection. Let $g$ be such that for each assignment $\langle \P,\e \rangle$, it holds that $g(\langle \P,\e \rangle) = \sigma$ where $\sigma$ is constructed as follows. For each $t_i\in T$, let $\sigma(t_i) = b^{\e}_i$. For each $p_{\ell,\b}^{\e}$, where $\ell\in\{1,\ldots,r\}$ and $\b\in A^{c_{\ell}}$, let $\sigma(p_{\ell,\b}^{\e}) = 1$ if and only if $\b \in P_{\ell}$. For each $p_{\ell,\b}^{\e'}$, where $\e'\in A^d\setminus\{\e\}$,  $\ell\in\{1,\ldots,r\}$ and $\b\in A^{c_{\ell}}$, let $\sigma(p_{\ell,\b}^{\e'}) = 1$. 
	
	Let $i$ be such that $\A\models \exists\x\,\varphi_i(\x,\P,\e)$. It is simple to see that from the way we constructed $\Phi_i^{\e}$, it holds that $\sigma(\Phi_i^{\e}) = 1$. Also, note that every different assignment $\langle \P',\e' \rangle$, it holds that $\sigma(\langle \P',\e' \rangle) \neq \sigma(\langle \P,\e \rangle)$. Therefore, $g$ is an injective function. Now, let $\sigma$ be an arbitrary assignment such that $\sigma(\Phi) = 1$. Let $i$ and $\e$ be such that $\sigma(\Phi^{\e}_i)$. Note that for every $\e'\in A^d\setminus\{\e\}$, it holds that $\sigma(\theta_{\e'}) = 0$, so there is exactly one possible $\e$ associated to $\sigma$. Consider the assignment $\P$ where $\b\in P_{\ell}$ if and only if $\sigma(p^{\e}_{\ell,\b}) = 1$, for each $\ell$ and $\b \in A^{c_{\ell}}$. Since there is at least one $\a\in\Gamma_i$ for which $\sigma$ satisfies its respective subformula, it holds that $\A\models\varphi_i(\a,\P,\e)$, which implies that $\A\models\exists\x\,\varphi(\x,\P,\e)$. From this we deduce that $g$ is surjective, and therefore a bijection. We conclude that $f(\A) = f_{\textsc{\#DNF}}(\A_{\Phi})$.
\end{enumerate}
	
\textbf{Proof of Theorem \ref{nplusone-strict}}

Suppose it is not properly contained for $n$. Let $\z = (z_1,\ldots,z_{n+1})$, let $\u = (u_1,\ldots,u_n)$ and let $\varphi(\z) = \bigwedge_{i = 1}^{n} (z_i < z_{i+1} \wedge \forall y(z_i\not<y \vee y\not<z_{i+1} )) \wedge \forall y(y \not< z_1)$. Note that $f_{\varphi(\z)}(\A) = 1$ if $\A$ has at least $n+1$ elements, and  $f_{\varphi(\z)}(\A) = 0$ otherwise, for each $\A\in\str$. Let $\forall\x\,\psi(\x,\X,\u)$ be such that $f_{\varphi(\z)} = f_{\forall\x\,\psi(\x,\X,\u)}$. Let $\A = \langle A, \S^{\A}, <^{\A} \rangle\in\str$ where $\vert A \vert = n+1$. Note that $f_{\forall\x\,\psi(\x,\X,\u)}(\A) = 1$. Let $(\P,\e)$ be such that $\A\models\forall\x\,\psi(\x,\P,\e)$. Let $a\in A$ be such that $a\not\in\e$. Consider the vocabulary $\L' = \L \cup \{\Q\}$, and let $\A' = \A \cup \langle \Q^{\A'} \rangle$ where $\Q^{\A'} = \P$. Note that $\A\models\varphi(\P,\e)$ if and only if $\A'\models\varphi(\e)$. Consider $\B'$ as the induced substructure of $\A'$ with domain $A\setminus\{a\}$, and let $\Q^{\B'}$ be the induced interpretation of $\Q$. Also let $\B$ be the induced substructure of $\A$ with domain $A\setminus\{a\}$. As universal formulae are preserved under substructure\footnote{Hodges, 1997. P. 183}, we have that $\B'\models\forall\x\,\psi(\x,\e)$, which implies that $\B\models\forall\x\,\psi(\x,\Q^{\B'},\e)$. We conclude that $f_{\forall\x\,\psi(\x,\X,\u)}(\B) \geq 1$, which leads to a contradiction.
	
\textbf{Proof of Theorem \ref{sigma2-pe}}

Let $f = f_{\varphi(\X,\z)}$ such that $\varphi(\X,\z)$ is defined by the grammar $E_2$. First we notice that, as stated in \cite{DBLP:journals/jcss/SalujaST95}, for every $\L$-formula $\varphi$, $f_{\varphi}\in\shp$.\\

We will now prove that there is a polynomial time algorithm that decides $L_{f}$. This is equivalent to decide, given $\A= \langle A, \S^\A, \leq^\A \rangle\in\str$, whether there exist assignments $\P,\z$ such that $\A\models\varphi(\P,\z)$. This is the same as $\A\models\exists\X\exists\x\,\varphi(\X,\x)$. Since $\varphi(\X,\x)$ is defined by the grammar $E_2$, there exists $\psi(\X,\x,\y,\u)$ such that $\varphi(\X,\x) = \exists\x\exists\y\forall\u\exists\v\,\psi(\X,\x,\y,\u,\v)$, where every variable in $\v$ appears on a negated second-order literal $\neg X_i$, with $i\in\N$.

Given $\A\in\str$ we generate an equivalent $\L$-formula $\theta(\X,\x,\y)$ with a series of operations. First, we replace every instance of $\v$ by a disjunction of all $r$-tuples in $A^r$, where $r$ is the number of variables in $\v$. The result is still a Horn clause. Second, we replace every instance of $\u$ by a conjunction of all $s$-tulples in $A^s$, where $s$ is the number or variables in $\u$. The result is still a conjunction of Horn clauses.

Now we notice that $\zeta = \exists\X\exists\x\exists\y\,\theta(\X,\x,\y)$ is an existential second-order FO-formula, for which $\A\models\zeta$ can be decided in polynomial time \cite{DBLP:conf/stacs/Gradel91}.
		
\textbf{Proof of Theorem \ref{sigma2hard}}

Let $f$ be an arbitrary function in $\XE{2}$. We will now show a function $h:\str\to L(P)$ such that for every $\A\in\str$, it holds that $f(\A) = \shdhsat(h(\A))$, and which can be computed in polynomial time. Let $\psi$ be such that $f = f_{\psi}$. We separate the proof in three cases:\begin{enumerate}
	\item All free variables in $\psi$ are of first order. Let $\psi = \exists \x \forall \y\,\varphi(\x,\y,\z)$ where $\z = (z_1,\ldots,z_d)$. Given a structure $\A = \langle A, \S^{\A}, \leq^{\A} \rangle\in\str$, we generate a propositional formula $\Phi = h(\A)$. First we notice that this case is trivial since we can calculate this function in polynomial time, by checking for each $\e\in A^d$ if $\A\models\exists\x\forall \y\,\varphi(\x,\y,\e)$. Let $n$ be the number of such assignments to $\z$. Let $\p$ be an $n$-tuple of propositional variables where $\p = (p_1,\ldots,p_n)$. The disjunction of Horn formulas we return is
	\[
	\Phi = \bigvee_{i = 1}^n \neg p_1 \wedge \cdots \wedge \neg p_{i-1} \wedge p_i \wedge \neg p_{i+1} \wedge \cdots \wedge \neg p_n
	\]
	which has exactly $n$ possible assignments. Note that each $p_i$ and $\neg p_i$ is a Horn clause itself.
	
	\item There are only second-order free variables in $\psi$. Let $\psi = \exists \x\forall \y\,\varphi(\x,\y,\X)$, where $\x = (x_1,\ldots,x_c)$, $\y = (y_1,\ldots,y_b)$, $\X = (X_1,\ldots,X_r)$ and each $X_{\ell}$ has arity $c_{\ell}$. Given a structure $\A = \langle A, \S^{\A}, \leq^{\A} \rangle\in\str$, we generate a Disj-Horn formula $\Phi = h(\A)$ as follows:
	
	First, Let $\varphi(\x,\y,\X) = \bigwedge_{i = 1}^k \varphi_{i}(\x,\y,\X)$ where, without loss of generality, each $\varphi_{i}(\x,\y,\X)$ is of the form
	\[
	\varphi_{i}(\x,\y,\X) = X_s(\u_{s}) \vee \neg X_{t_1}(\u_{t_1}) \vee \cdots \vee \neg X_{t_n}(\u_{t_n}) \vee \alpha_i(\x,\y),
	\]
	where $\u_{s}$ and every $\u_{t_j}$ have the corresponding number of variables in $(\x,\y)$, and $\alpha(\x,\y)$ is a FO-formula. For the rest of the proof, $X_s(\u_s)$ can be absent and it does not affect the proof. Note that this formula is equivalent to
	\[
	\neg\alpha_i(\x,\y) \to (X_s(\u_{s}) \vee \neg X_{t_1}(\u_{t_1}) \vee \cdots \vee \neg X_{t_n}(\u_{t_n})),
	\]
	
	Then, for each $\a\in A^c$ let $\Gamma_i^{\a} = \{\b\in A^{b}\mid \A\models\neg\alpha(\a,\b)\}$. Note that this set can be generated in polynomial time. For each $\ell\in\{1,\ldots,r\}$, we generate a propositional variable $p^{\ell}_{\d}$ for each $\d\in A^{c_{\ell}}$. Let $\p$ be the tuple of all such variables. Also, let $\rho_{\ell}(\x,\y) = \u_{\ell}$, and $\rho_{\ell}(\d)$ be the tuple that results of reordering $\d$ using the reordering of the variables of $(\x,\y)$ in $\u_{\ell}$.
	
	For each $\a\in A^c$ we generate a Horn formula
	\[
	\Phi_{\a}^i = \bigwedge_{\b\in\Gamma_i} p^{s}_{\rho_s(\a,\b)} \vee \neg p^{t_1}_{\rho_{t_1}(\a,\b)} \vee \cdots \vee \neg p^{t_n}_{\rho_{t_n}(\a,\b)}.
	\]
	and finally we return $\Phi = \bigvee_{\a\in A^c} \bigwedge_{i = 1}^k \Phi_{\a}^i$.
	
	Note that for each assignment $\P$ to $\X$ such that $\A\models\exists\x\forall\y\,\varphi(\x,\y,\P)$ there is a corresponding assignment $\sigma$ to $\p$ where $\sigma(p^{\ell}_{\a}) = 1$ if and only if $\a\in P_{\ell}$. We can conclude that $f(\A) = f_{\textsc{Disj-Horn-Sat}}(\Phi)$.
	
	\item Let $\psi = \exists \x\forall\y\,\varphi(\x,\y,\X,\z)$, where $\x = (x_1,\ldots,x_c)$, $\y = (y_1,\ldots,y_b)$, $\z = (z_1,\ldots,z_d)$, $\X = (X_1,\ldots,X_r)$ and each $X_{\ell}$ has arity $c_{\ell}$. Given a structure $\A = \langle A, \S^{\A}, \leq^{\A} \rangle\in\str$ we generate a Disj-Horn formula $\Phi = h(\A)$ as follows:
	
	As in the previous case, let $\varphi(\x,\y,\X,\z) = \bigwedge_{i = 1}^k$ where $\varphi(\x,\y,\X,\z)$ is of the form:
	\[
	\varphi_{i}(\x,\y,\X,\z) = X_s(\u_{s}) \vee \neg X_{t_1}(\u_{t_1}) \vee \cdots \vee \neg X_{t_n}(\u_{t_n}) \vee \alpha_i(\x,\y,\z),
	\]
	where $\u_{s}$ and every $\u_{t_j}$ have the corresponding number of variables in $(\x,\y,\z)$, and $\alpha(\x,\y,\z)$ is a FO-formula. For the rest of the proof, $X_s(\u_s)$ can be absent and it does not affect the proof. Note that this formula is equivalent to
	\[
	\neg\alpha_i(\x,\y,\z) \to (X_s(\u_{s}) \vee \neg X_{t_1}(\u_{t_1}) \vee \cdots \vee \neg X_{t_n}(\u_{t_n})).
	\]
	
	For each $\e\in A^d$, we do the following. For each $\a\in A^c$ let $\Gamma^{\e}_{i,\a} = \{\b \in A^b \mid \A\models \neg\alpha_i(\a,\b,\e) \}$. Note that this set can be generated in polynomial time. For each $\ell\in\{1,\ldots,r\}$ we generate a propositional variable $p^{\e}_{\ell,\d}$ for each $\d\in A^{c_{\ell}}$. Let $\p$ be the tuple of all such variables. We also generate a set $T = \{t_1,\ldots,t_{L}\}$ where $L = \lceil \log\vert A^d\vert \rceil$, and an arbitrary injective function $\beta:A^d \to \{0,1\}^L$ where $\beta(\e) = (b^{\e}_1,\ldots,b^{\e}_L)$ for each $\e\in A^d$. Also, let $\rho_{\ell}(\x,\y,\z) = \u_{\ell}$, and $\rho_{\ell}(\d)$ be the tuple that results of reordering $\d$ using the order of the variables in $(\x,\y,\z)$ in $\u_{\ell}$. And so, the Horn formula we generate is
	\[
	\Phi^{\e}_{i,\a} = \bigwedge_{\a\in\Gamma^{\e}_i} p^{\e}_{s,\rho_{s}(\a,\b,\e)} \vee p^{\e}_{t_1,\rho_{t_1}(\a,\b,\e)} \vee \cdots \vee p^{\e}_{t_n,\rho_{t_n}(\a,\b,\e)}.
	\]
	And finally we return $\Phi = \bigvee_{\e\in A^d}\bigvee_{\a\in A^c} (\bigwedge_{i=1}^k \Phi_{\e}^{i,\a} \wedge \gamma_{\e} \wedge \theta_{\e} )$, where $\gamma_{\e}$ is defined as
	\[
	\gamma_{\e} = \bigwedge_{\e'\in A^d\setminus\{\e\}} \bigwedge_{\ell = 1}^r \bigwedge_{\b\,\in A^{c_{\ell}}} p_{\ell,\b}^{\e'},
	\]
	and $\theta_{\e}$ is defined as
	\[
	\theta_{\e} = \bigwedge_{i\in[1,L]:\,b^{\e}_i = 0} \neg t_i\  \wedge \bigwedge_{i\in[1,L]:\,b^{\e}_i = 1} t_i.
	\]
	
\end{enumerate}



\textbf{Proof of Theorem \ref{so-rec}}


\textbf{Proof of Theorem \ref{tqfo-fo-cap}}

For the second condition, let $f \in \shl$. We will address the case where $\R$ contains only one binary predicate $E$, and the rest of the cases can be deduced from this. Let $M$ be a non-deterministic logspace machine such that $f(\A) = \acc_M(\A)$ for each $\A \in \ostr[R]$. Suppose ${\cal Q} = \{q_1,\ldots,q_{\ell}\}$ is the set of states of $M$, where $q_1$ is the initial state, and $q_{\ell}$ is only final state of $M$. Let $n = \vert A \vert$ and let $w = \enc(\A) \in \{0,1\}^{n^2}$. We assume that $M$ with input $w$ uses space $s_M(w) < c\cdot\log(n)$ and furthermore, $s_M(w) < n-2$. We notate $M(w)$ as the graph of configurations of $M$ running on input $w$.

We represent configurations with a tuple of fixed size. The formula $\varphi(\bar{x},\bar{y})$ describes a procedure that given a configuration generates a possible next configuration. The formula $\varphi_I(\bar{x})$ describes that $\bar{x}$ is the initial configuration of $M(w)$. The formula $\varphi_F(\bar{x})$ describes that $\bar{x}$ is an accepting (final) configuration of $M(w)$. The formula we construct is:
$$
\alpha = \sa{\bar{x}}\sa{\bar{y}}([\pth \varphi(\bar{u},\bar{v})](\bar{x},\bar{y})\cdot \varphi_I(\bar{x})\cdot\varphi_F(\bar{y})).
$$

To illustrate our idea, we will show a simplified example. Consider a machine $M$ that works in exactly $\log_2(n)$ space and only allows 0 or 1 in the working tape. Consider an input $\A$ of size 16 (that is, $A = \{0,\ldots,9,A,\ldots,F\}$). Let some configuration $s$ have 0011 in the working tape, the head in the input tape is in position 26, and the head in the input tape is in position 2 (we consider 0-indexed positions). Also, $Q = \{q_1,\ldots,q_5\}$ and the current state is $q_3$.

As a first approach, we will use a 9-tuple $\bar{a} = (a_1,\ldots,a_9)$ to represent $s$. That is, $(a_1,a_2) = (1,A)$ represent the position of the head in the input tape, $a_3 = 2$ represents the position of the head in the working tape, $a_4 = C$ (1100b in base 16) represents the content of the working tape, and $(a_5,\ldots,a_9) = (0,0,1,0,0)$ represents the current state. Then $\bar{a} = (1,A,2,C,0,0,1,0,0)$ will represent $s$.

The problem that arises from this representation, is that to describe a transition in $M$ we need to read an arbitrary character in the working tape, and therefore we have to obtain the $a_3$-th bit in $a_4$. Furthermore, to represent the following configuration, we need compute $a_4$ with the $a_3$-th bit flipped. This is generally not possible to describe with an $\fo$ formula. Consider the following procedure that receives $x = a_4$ and $i = a_3$.

\begin{algorithm}
	\caption{If the $i$-th bit in $x$ is 1 replace it by 0 and return the result}
	\label{switch1to0}
	\begin{algorithmic}
		\State $u \gets x,\; j \gets i$ \Comment{Get the $i$-th bit on $x$ and store it in $u$}
		\While{$j > 0$}
		\State $v \gets 0$
		\While{$u > 1$}
		\State $u \gets u-2,\; v \gets v+1$
		\EndWhile
		\State $u\gets v,\; j \gets j-1$
		\EndWhile
		\While{$u > 1$}
		\State $u \gets u-2$
		\EndWhile
		\State $\textbf{assert } u = 1$ \Comment{If $u \neq 1$ simply stop}	
		\State $y \gets 1$ \Comment{Compute $2^i$ and store it in $y$}
		\While{$i > 0$}
		\State $z \gets 0$
		\While{$y > 0$}
		\State $z \gets z+2,\; y \gets y-1$
		\EndWhile
		\State $i \gets i-1,\; y \gets z$
		\EndWhile
		\While{$y > 0$} \Comment{Substract $y$ from $x$}
		\State $x \gets x-1,\; y \gets y-1$
		\EndWhile
		\State \Return $x$.
	\end{algorithmic}
\end{algorithm}	
Each of the instructions can be expressed with $\fo$, so our strategy is to use the $\pth$ operator to simulate the algorithm and then we can describe a transition using the processed value of $a_4$. Note that we need to describe three more procedures to simulate the transitions for $0\to 0$, $0 \to 1$ and $1\to 1$.

We will now describe how to simulate both the procedure and the transition. A procedure tuple $\bar{p} = (a_1,\ldots,a_{3+c+\ell},b_1,b_2,c_1,c_2,c_3,d_1,\ldots,d_{5c+2})$ represents the current configuration of $M(w)$ in $a_1,\ldots,a_{2+c+\ell}$, the values that will be read and written in the working tape in $b_1,b_2$, the instruction pointer in $c_1,c_2,c_3$ and the values stored in memory in $d_1,\ldots,d_{10c+2}$. In detail:
\begin{enumerate}
	\item $a_1,a_2$ and $a_3$ represent the position of the head in the input tape and the working tape, respectively, $a_4,\ldots,a_{3+c}$ represent the content of the working tape and $a_{4+c},\ldots,a_{3+c+\ell}$ represent the current state in the current configuration that is being processed.
	\item $b_1$ and $b_2$ are equal to the value that is being read in the working tape and the value that will be written in the working tape respectively.
	\item $c_1,c_2,c_2$ represent the instruction pointer in the procedure. Only 8 different instructions are needed in the simulation.
	\item Each value in memory of $x,y,z,u,v$ need $c$ elements to represent them and $i,j$ need only one. We map $(d_1\ldots,d_{c}) \to x$, $(d_{c+1}\ldots,d_{2c}) \to y$,
	$(d_{2c+1}\ldots,d_{3c}) \to z$, $(d_{3c+1}\ldots,d_{4c}) \to u$,
	$(d_{4c+1}\ldots,d_{5c}) \to v$, $d_{5c+1} \to i$ and $d_{5c+2}\to j$.
\end{enumerate}
For each transition $\delta \in \Delta \subseteq Q \times \{0,1\} \times \{0,1\} \times Q \times \{-1,=,+1\} \times \{0,1\} \times \{-1,=,+1\}$ we define a formula $\varphi_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v})$, where $\bar{x} = (x_1,\ldots,x_{3+c+\ell})$, $\bar{s} = (s_1,s_2)$, $\bar{w} = (w_1,w_2,w_3)$, $\bar{u} = (u_1,\ldots,u_{5c+2})$, $\bar{y} = (y_1,\ldots,y_{3+c+\ell})$, $\bar{t} = (t_1,t_2)$, $\bar{z} = (z_1,z_2,z_3)$ and $\bar{v} = (v_1,\ldots,v_{5c+2})$. The tuples $\bar{x}$ and $\bar{y}$ represent the current and next configuration of $M$ respectively, $\bar{s}$ and $\bar{y}$ indicate which algorithm is being followed, $\bar{w}$ and $\bar{z}$ represent the current and next instruction of the algorithm, $\bar{u}$ and $\bar{v}$ represent the current and next values in memory. We will describe the formula part by part. Suppose $\delta = (q_i,a,1,q_j,op_1,0,op_2)$, so we have to simulate Algorithm \ref{switch1to0}.

First we define some auxiliary formulas:
\begin{align*}
\varphi_0(x) &= \neg\exists y(y < x), \\
\varphi_{+1}(x,y) &= x < y \wedge \neg\exists z(x < z \wedge z < y), \\
\varphi_{-1}(x,y) &= \varphi_{+1}(y,x), \\
\varphi_1(x) &= \exists y(\varphi_0(y) \wedge \varphi_{+1}(y,x)), \\
\text{for $i,j \in\{0,1\}$, }	\varphi_{i,j}(x,y) &= \varphi_i(x) \wedge \varphi_j(y), \\
\text{for each $k \leq 7$, }\varphi^b_k(x_1,x_2,x_3) &= \varphi_{a_1}(x_1) \wedge \varphi_{a_2}(x_2) \wedge \varphi_{a_3}(x_3)\text{, where $a_1a_2a_3$ is the value of $k$ in binary}, \\
\mu_{<}(x_1,\ldots,x_c,y_1,\ldots,y_c) &= \bigvee_{i = 1}^c ((\bigwedge_{j = 1}^{i-1} x_j = y_j) \wedge x_i < y_i), \\
\mu_{+1}(\bar{x},\bar{y}) &= \mu_{<}(\bar{x},\bar{y}) \wedge \neg\exists \bar{z}(\mu_{<}(\bar{x},\bar{z}) \wedge \mu_{<}(\bar{z},\bar{y})), \\
\mu_{+2}(\bar{x},\bar{y}) &= \exists\bar{z}(\mu_{+1}(\bar{x},\bar{z}) \wedge \mu_{+1}(\bar{z},\bar{y})),\\
\mu_{-1}(\bar{x},\bar{y}) &= \varphi_{+1}(\bar{y},\bar{x}),\\
\mu_{-2}(\bar{x},\bar{y}) &= \varphi_{+2}(\bar{y},\bar{x}),\\
\mu_{0}(\bar{x}) &= \neg\exists\bar{y}(\mu_{<}(\bar{y},\bar{x})),\\
\mu_{1}(\bar{x}) &= \exists\bar{y}(\mu_{0}(\bar{y})\wedge\mu_{+1}(\bar{y},\bar{x})),\\
\varphi^2_{<}(x_1,x_2,y_1,y_2) &= x_1 < y_1 \vee (x_1 = y_1 \wedge x_2 < y_2),\\
\varphi^2_{+1}(x_1,x_2,y_1,y_2), \varphi^2_{-1}(x_1,x_2,y_1,y_2) &\text{ defined analogously to $\mu_{+1}$ and $\mu_{-1}$},\\
\text{for each } q_i\in Q, \varphi^q_i(x_1,\ldots,x_{\ell}) &= \bigwedge_{\substack{j = 1 \\ j \neq i}}^{\ell} \varphi_0(x_j) \wedge \varphi_1(x_i), \\
\varphi^E_0(x_1,x_2) &= \neg E(x_1,x_2),\\		\varphi^E_1(x_1,x_2) &= E(x_1,x_2),\\
\end{align*}

We start from instruction 0, which means that the procedure has not started yet and every value in the tuple is 0 except for the configuration values. It also initializes all the values in the tuple to 0 except for $x,u,i,j$.
\begin{multline*}
\varphi^{0,1}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{0,0}(s_1,s_2)\wedge\varphi^b_0(\bar{w}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_1(\bar{z})\, \wedge \\ 
\bigwedge_{i = 1}^c v_i = x_{3+i} \wedge \bigwedge_{i = c+1}^{2c} \varphi_0(v_i) \wedge \bigwedge_{i = 2c+1}^{3c} \varphi_0(v_i) \wedge \bigwedge_{i = 1}^c v_{3c+i} = x_{3+i} \wedge \bigwedge_{i = 4c+1}^{5c} \varphi_0(v_i) \wedge v_{5c+1} = x_3 \wedge v_{5c+2} = x_3.
\end{multline*}
Instruction 1 which checks whether the value of $j$ ($d_{5c+2}$ in the tuple) is more than 0 or not, and then proceeds to instruction 2 or 3 on each case.
\begin{multline*}
\varphi^{1,2}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 
\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_1(\bar{w}) \wedge \neg \varphi_0(u_{5c+2}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_2(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i, \\
\varphi^{1,3}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 
\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_1(\bar{w}) \wedge \varphi_0(u_{5c+2}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_3(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i.
\end{multline*}
Instruction 2 checks the value of $u$ ($d_{3c+1},\ldots,d_{4c}$ in the tuple). If it is $> 1$ then it substracts 2 from $u$ and adds 1 to $v$ ($d_{4c+1},\ldots,d_{5c}$ in the tuple), then repeats instruction 2. If it is equal to 0 or 1, then moves the value of $v$ to $u$, substracts 1 from $j$ and goes back to instruction 1.
\begin{multline*}
\varphi^{2,2}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 
\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_2(\bar{w}) \wedge \neg \mu_0(u_{3c+1},\ldots,u_{4c}) \wedge \neg \mu_1(u_{3c+1},\ldots,u_{4c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_2(\bar{z})\, \wedge \\
\bigwedge_{i = 1}^c u_i = v_i \wedge
\bigwedge_{i = c+1}^{2c} u_i = v_i \wedge
\bigwedge_{i = 2c+1}^{3c} u_i = v_i \wedge
\mu_{-2}(u_{3c+1},\ldots,u_{4c},v_{3c+1},\ldots,v_{4c})\, \wedge \\
\mu_{+1}(u_{4c+1},\ldots,u_{5c},v_{4c+1},\ldots,v_{5c}) \wedge u_{5c+1} = v_{5c+1} \wedge u_{5c+2} = v_{5c+2}. \\
\varphi^{2,1}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_2(\bar{w}) \wedge ( \mu_0(u_{3c+1},\ldots,u_{4c}) \vee \mu_1(u_{3c+1},\ldots,u_{4c})) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_1(\bar{z})\, \wedge \\
\bigwedge_{i = 1}^c u_i = v_i \wedge
\bigwedge_{i = c+1}^{2c} u_i = v_i \wedge
\bigwedge_{i = 2c+1}^{3c} u_i = v_i \wedge
\bigwedge_{i = 3c+1}^{4c} u_{c+i} = v_i \wedge
\mu_0(v_{4c+1},\ldots,v_{5c}) \wedge
u_{5c+1} = v_{5c+1} \wedge \varphi_{-1}(u_{5c+2},v_{5c+2}).	
\end{multline*}
Instruction 3 calculates the value of $u \mod 2$, that is, it repeats instruction 3 until the value of $u$ is equal to 0 or 1. On each iteration, it substracts 2 from $u$. Moreover, if the value of $u$ at the end of the iterations is not 1 then there is no step defined.
\begin{multline*}
\varphi^{3,3}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_3(\bar{w}) \wedge \neg \mu_0(u_{3c+1},\ldots,u_{4c}) \wedge \neg \mu_1(u_{3c+1},\ldots,u_{4c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_3(\bar{z})\, \wedge \\
\bigwedge_{i = 1}^c u_i = v_i \wedge
\bigwedge_{i = c+1}^{2c} u_i = v_i \wedge
\bigwedge_{i = 2c+1}^{3c} u_i = v_i \wedge
\mu_{-2}(u_{3c+1},\ldots,u_{4c},v_{3c+1},\ldots,v_{4c}) \wedge
\bigwedge_{i = 4c+1}^{5c} u_i = v_i \wedge
u_{5c+1} = v_{5c+1} \wedge u_{5c+2} = v_{5c+2}, \\
\varphi^{3,3}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 
\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_3(\bar{w}) \wedge \mu_1(u_{3c+1},\ldots,u_{4c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_4(\bar{z})\, \wedge \\
\bigwedge_{i = 1}^c u_i = v_i \wedge
\mu_1(v_{c+1},\ldots,v_{2c}) \wedge
\bigwedge_{i = 2c+1}^{3c} u_i = v_i \wedge
\bigwedge_{i = 3c+1}^{4c} u_i = v_i \wedge
\bigwedge_{i = 4c+1}^{5c} u_i = v_i \wedge
u_{5c+1} = v_{5c+1} \wedge u_{5c+2} = v_{5c+2}
\end{multline*}
Instruction 4 checks the value of $i$ ($d_{5c+1}$ in the tuple.) If it is not 0 then goes to instruction 5 and if is 0 then goes to instruction 6. Moreover it initializes the value of $z$ ($d_{2c+1},\ldots,d_{3c}$ in the tuple) to 0 (which was 0 all along.)
\begin{multline*}
\varphi^{4,5}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_4(\bar{w}) \wedge \neg \varphi_0(u_{5c+1}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_5(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i, \\
\varphi^{4,6}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_4(\bar{w}) \wedge \varphi_0(u_{5c+1}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_6(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i.
\end{multline*}
Instruction 5 checks the value of $y$ ($d_{c+1},\ldots,d_{2c}$ in the tuple.) If it is more than 0 then it adds 2 to $z$ and substracts 1 from $y$, then repeats instruction 2. If it is not, then copies the value of $z$ to $y$ and subtracts 1 from $i$ and returns to instruction 4.
\begin{multline*}
\varphi^{5,5}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_5(\bar{w}) \wedge \neg \mu_0(u_{c+1},\ldots,u_{2c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_5(\bar{z}) \, \wedge \\
\bigwedge_{i = 1}^c u_i = v_i \wedge
\mu_{-1}(u_{c+1},\ldots,u_{2c},v_{c+1},\ldots,v_{2c}) \wedge
\mu_{+2}(u_{2c+1},\ldots,u_{3c},v_{2c+1},\ldots,v_{3c})\, \wedge \\
\bigwedge_{i = 3c+1}^{4c} u_i = v_i \wedge
\bigwedge_{i = 4c+1}^{5c} u_i = v_i \wedge
u_{5c+1} = v_{5c+1} \wedge u_{5c+2} = v_{5c+2}, \\
\varphi^{5,4}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_5(\bar{w}) \wedge \mu_0(u_{c+1},\ldots,u_{2c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_4(\bar{z}) \, \wedge \\
\bigwedge_{i = 1}^c u_i = v_i \wedge
\bigwedge_{i = c+1}^{2c} u_{c+i} = v_i \wedge
\mu_0(v_{2c+1},\ldots,v_{3c}) \wedge
\bigwedge_{i = 3c+1}^{4c} u_i = v_i \wedge
\bigwedge_{i = 4c+1}^{5c} u_i = v_i \wedge
\varphi_{-1}(u_{5c+1},v_{5c+1}) \wedge u_{5c+2} = v_{5c+2}
\end{multline*}
Instruction 6 checks the value of $y$. If it is more than 0, then subtracts 1 from $x$ and $y$ and repeats instruction 6. If it is not, then goes to instruction 7.
\begin{multline*}
\varphi^{6,6}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_6(\bar{w}) \wedge \neg \mu_0(u_{c+1},\ldots,u_{2c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_6(\bar{z}) \, \wedge \\
\mu_{-1}(u_1,\ldots,u_c,v_i,\ldots,v_c) \wedge \mu_{-1}(u_{c+1},\ldots,u_{2c},v_{c+1},\ldots,v_{2c}) \wedge \bigwedge_{i = 3c+1}^{5c+2} u_i = v_i]\,\vee \\
\varphi^{6,7}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_6(\bar{w}) \wedge \mu_0(u_{c+1},\ldots,u_{2c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_7(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i.
\end{multline*}
Instruction 7 stores the value of $x$ after the corresponding bit has been switched. Then we can define $\varphi_{\delta}$ which also simulates the actual transition. If $u$ equals 1, then copy what is stored in $x$ to $a_4,\ldots,a_{3+c}$, go from state $q_i$ to state $q_j$, and move the heads to their corresponding positions.
\begin{multline*}
\varphi_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 	[\bigwedge_{i = 1}^{3+c+\ell} x_i = y_i \wedge (\varphi^{0,1}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{1,2}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v})\, \vee \\ \varphi^{1,3}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{2,2}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{2,1}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{3,3}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \\ \varphi^{3,4}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{4,5}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{4,6}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{5,5}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \\ \varphi^{5,6}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{6,6}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{6,7}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}))] \, \vee \\
[\varphi^E_a(x_1,x_2) \wedge \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_7(\bar{w}) \wedge \mu_1(u_{3c+1},\ldots,u_{4c}) \wedge \varphi_{0,0}(t_1,t_2) \wedge \varphi^b_0(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i \,\wedge \\
\varphi^2_{op_1}(x_1,x_2,y_1,y_2) \wedge \varphi_{op_2}(x_3,y_3) \wedge \bigwedge_{i = 1}^c u_i = x_{3+i} \wedge \varphi^q_i(x_{4+c},\ldots,x_{3+c+\ell}) \wedge \varphi^q_j(y_{4+c},\ldots,y_{3+c+\ell})].
\end{multline*}


\begin{algorithm}
	\caption{If the $i$-th bit in $x$ is 0 return $x$} \label{switch0to0}
	\begin{algorithmic}
		\State $u \gets x,\; j \gets i$ \Comment{Get the $i$-th bit on $x$ and store it in $u$}
		\While{$j > 0$}
		\State $v \gets 0$
		\While{$u > 1$}
		\State $u \gets u-2,\; v \gets v+1$
		\EndWhile
		\State $u\gets v,\; j \gets j-1$
		\EndWhile
		\While{$u > 1$}
		\State $u \gets u-2$
		\EndWhile
		\State $\textbf{assert } u = 0$ \Comment{If $u \neq 0$ simply stop}	
		\State \Return $x$.
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{If the $i$-th bit in $x$ is 0 replace it by 1 and return the result}
	\label{switch0to1}
	\begin{algorithmic}
		\State $u \gets x,\; j \gets i$ \Comment{Get the $i$-th bit on $x$ and store it in $u$}
		\While{$j > 0$}
		\State $v \gets 0$
		\While{$u > 1$}
		\State $u \gets u-2,\; v \gets v+1$
		\EndWhile
		\State $u\gets v,\; j \gets j-1$
		\EndWhile
		\While{$u > 1$}
		\State $u \gets u-2$
		\EndWhile
		\State $\textbf{assert } u = 0$ \Comment{If $u \neq 0$ simply stop}	
		\State $y \gets 1$ \Comment{Compute $2^i$ and store it in $y$}
		\While{$i > 0$}
		\State $z \gets 0$
		\While{$y > 0$}
		\State $z \gets z+2,\; y \gets y-1$
		\EndWhile
		\State $i \gets i-1,\; y \gets z$
		\EndWhile
		\While{$y > 0$} \Comment{Add $y$ to $x$}
		\State $x \gets x+1,\; y \gets y-1$
		\EndWhile
		\State \Return $x$.
	\end{algorithmic}
\end{algorithm}	

\begin{algorithm}
	\caption{If the $i$-th bit in $x$ is 1 return $x$}
	\label{switch1to1}
	\begin{algorithmic}
		\State $u \gets x,\; j \gets i$ \Comment{Get the $i$-th bit on $x$ and store it in $u$}
		\While{$j > 0$}
		\State $v \gets 0$
		\While{$u > 1$}
		\State $u \gets u-2,\; v \gets v+1$
		\EndWhile
		\State $u\gets v,\; j \gets j-1$
		\EndWhile
		\While{$u > 1$}
		\State $u \gets u-2$
		\EndWhile
		\State $\textbf{assert } u = 1$ \Comment{If $u \neq 0$ simply stop}	
		\State \Return $x$.
	\end{algorithmic}
\end{algorithm}
Note that we also need to specify that the program we are following is Algorithm \ref{switch1to0} so we store $1,0$ in $b_1,b_2$ all along the procedure. We describe the three other algorithms that compute the switches from $0\to 0$, $0\to 1$ and $1\to 1$ (Algorithms \ref{switch0to0}, \ref{switch0to1} and \ref{switch1to1}.)
For the other three cases, where $\delta = (q_i,a,0,q_j,op_1,0,op_2)$, $\delta = (q_i,a,0,q_j,op_1,1,op_2)$ and $\delta = (q_i,a,1,q_j,op_1,1,op_2)$, $\varphi_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v})$ is defined analogously. Then, $\varphi(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v})$ is defined as:
$$
\varphi(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \bigvee_{\delta \in \Delta} \varphi_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}).
$$
Finally we define $\varphi_I$ and $\varphi_F$:
\begin{align*}
\varphi_I(\bar{x},\bar{s},\bar{w},\bar{u}) &= \varphi_0(x_1) \wedge \varphi_0(x_2) \wedge \varphi_0(x_3) \wedge \bigwedge_{i = 4}^{3+c}\varphi_0(x_i) \wedge \varphi_1(x_{4+c}) \wedge \bigwedge_{i = 5+c}^{3+c+\ell} \varphi_0(x_i)\wedge \varphi_{0,0}(s_1,s_2)\ \wedge \varphi^b_0(\bar{w}) \wedge \bigwedge_{i = 1}^{5c+2}\varphi_0(u_i). \\
\varphi_F(\bar{x},\bar{s},\bar{w},\bar{u}) &= \varphi^q_{\ell}(x_{4+c},\ldots,x_{3+c+\ell}) \wedge \varphi_{0,0}(s_1,s_2)\ \wedge \varphi^b_0(\bar{w}) \wedge \bigwedge_{i = 1}^{5c+2}\varphi_0(u_i),
\end{align*}
and then $\sem{\alpha}(\A) = \sem{\sa{\bar{x}}\sa{\bar{y}}([\pth \varphi(\bar{u},\bar{v})](\bar{x},\bar{y})\cdot \varphi_I(\bar{x})\cdot\varphi_F(\bar{y}))}(\A) = \acc_M(\A)$.

\textbf{Proof of Theorem \ref{tqso-fo-cap}}


\textbf{Proof of Theorem \ref{rqfo-fo-cap}}



%!TEX root = main.tex

%
%\marcelo{Enfatizar el rol fundamental de la logica para obtener los resultados, por ejemplo para obtener cerrado bajo menos uno}
%
%Strategy:
%\begin{enumerate}
%	\item Descriptive complexity and application.
%	
%	\item Counting complexity classes. 
%	
%	\item Our contribution in terms of logic.
%	
%	\item sharP and its structure. 
%	
%	\item Syntactic classes with good properties. 
%\end{enumerate}
%
%\cristian{Aqui empieza la intro.}

The goal of descriptive complexity is to measure the complexity of a problem in terms of the logical constructors needed to express it~\cite{I99,G07}. 
The starting point of this branch of complexity theory is Fagin's theorem, which states that $\np$ is equal to existential second-order logic. Since then, many more complexity classes have been characterized in terms of logics (see \cite{G07} for a survey) and descriptive complexity has found a variety of applications in different areas like databases~\cite{V82,I86,ACY91,G92} and computational complexity~\cite{AV95,I99,L04,G07}.
For instance, Fagin's theorem was the key ingredient in the area of optimization algorithms to define the class {\sc MaxSNP}~\cite{PY91}, which was later shown to be a fundamental class in the study of hardness of approximation \cite{ALMSS98,V04}. 
It is important to mention here that the definition of {\sc MaxSNP} would not have been possible without the machine-independent point of view of descriptive complexity, as pointed out in~\cite{PY91}.

Counting problems differ from decision problems in that the value of a function has to be computed.
More generally, a counting problem corresponds to compute a function $f$ from a set of instances (e.g. graphs, formulas, etc) to natural numbers (usually, this value corresponds to count the number of solution for a given instance in a search problem~\cite{valiant-paper}). 
The study of counting problems has given rise to a rich theory of counting complexity classes \cite{HV95,F97,HO02,AB09}. Some of these classes are natural counterparts of some classes of decision problems; for example, $\fp$ ($\fpspace$) is the class of all functions that can be computed in polynomial time (space resp.), the natural counterpart of $\ptime$ ($\pspace$ resp.). 
However, other function complexity classes have emerged from the need to understand the complexity of some function problems for which little can be said if their decision counterparts are considered. This is the case of the class $\shp$, a counting complexity class introduced in \cite{Valiant79} to prove that computing the permanent of a matrix is a difficult problem. More specifically, it was shown in  \cite{Valiant79}  that this problem is $\shp$-complete. As a consequence of this result, the $\shp$-completeness of many other problems was shown like, for example, computing the number of perfect matchings of a bipartite graph, the number of satisfying assignments of a 2-CNF propositional formula or simple paths from a source node to a target node in a directed graph ($\csp$) \cite{V79b} among other (see \cite{BW05} for a complete list). 
Then, starting from $\shp$ the zoo of counting complexity classes was open with other natural counting classes like $\spp$, $\shl$, and $\totp$ with their respectively characteristic complete problems.

Although counting problems play a prominent role in computational complexity, descriptive complexity for this type of problems has not been systematically studied and it is not as developed as for the case of decision problems. Insightful characterizations of $\shp$ and some of its extensions have been provided \cite{SST95,B95,CG96}. However, these characterizations do not define function problems in terms of a logic, but instead in terms of some counting problems associated to a logic. Thus, it is not clear how these characterizations can be used to provide a general descriptive complexity framework for counting complexity classes like $\fp$ and $\fpspace$.
%It should be mentioned that logical definability has also been studied for the case of optimization problems \cite{KT94} and computation over the real numbers \cite{GM95}. As for the previous cases, it is not clear how these approaches can be extended to provide logical characterizations of a variety of function complexity classes. 

In this paper, we propose to study the descriptive complexity of counting complexity classes in terms of Weighted Logics (WL)~\cite{DrosteG07}, a general logical framework that combines boolean formulas (e.g. FO, SO) with operations over a fix semirings (e.g. $\bbN$). 
Specifically, we propose to restrict WL over natural numbers, called Quantitative Second Order Logics (QSO), and study its expressive power for defining counting complexity classes over general structures. 
As a proof of concept, we show that natural syntactical fragments of $\qso$ captures natural counting complexity classes like $\shp$, $\spp$, $\fp$ and $\fpspace$.
Although $\shp$ and $\spp$ was captured in~\cite{SST95,B95,CG96}, this is the first framework that can naturally capture $\fp$ and $\fpspace$.

The next step of our work is to use our logical framework to search for robust subclasses of $\shp$ similar than the class {\sc MaxSNP} for optimization problems.
With this definition of robust class we search inside $\shp$ for such a class. 
We study a class.... 
Another natural class is to find classes with natural complete problems.  Unfortunately, it is not clear that the previous class contain such a complete problem. Then we propose another class related with horn classes and show that a natural problem is complete for this class. 
We believe that this is the first step in finding robust classes with natural complete problems. 

Finally, we study extentions of our framework to capture other complexity classes. Whe show how to introduce recursion. 

\cristian{TODO EN CONSTRUCCION}
%
%The class $\shp$ was introduced in \cite{Valiant79} to prove that computing the permanent of a matrix is a difficult problem. More specifically, it was shown in  \cite{Valiant79}  that this problem is $\shp$-complete. 
%%As a consequence of this result the $\shp$-completeness of the problem of computing the number of perfect matchings of a bipartite graph ($\cpm$) was established.
%Since then  many counting problems have been proved to be $\shp$-complete \cite{V79b,PB83,P86,L86,BW91,HMRS98,DG00,BW05,DS12, PS13,PS14}. Among them, problems having easy decision counterparts play a fundamental role, as a counting problem with a hard decision version is expected to be hard. Formally, the decision problem associated to a function $f : \Sigma^* \to \mathbb{N}$ is defined as $L_f = \{ x \in \Sigma^* \mid f(x) > 0 \}$, and $f$ is said to have an easy decision version if $L_f \in \ptime$. A first prominent example of such functions is $\cpm$, as it is well-known that the problem of verifying whether there exists a perfect matching in a bipartite graph can be solved in polynomial time. 
%Other prominent examples of such problems include counting the number of: satisfying assignments of a 2-CNF propositional formula ($\ctwcnf$) \cite{V79b}, satisfying assignments of a DNF propositional formula ($\cdnf$) \cite{DHK05}, satisfying assignments of a Horn  propositional formula ($\chsat$) \cite{V79b}, simple paths from a source node to a target node in a directed graph ($\csp$) \cite{V79b}, extensions of a partial order to a linear order \cite{BW91} and Eulerian cycles in an undirected graph \cite{BW05}. 
%Counting problems with easy decision versions play also a fundamental role in the search of efficient approximations algorithms for functions in $\shp$. A fully-polynomial randomized approximation scheme (FPRAS) for a function $f : \Sigma^* \to \bbN$ is a randomized algorithm that computes . Notably, there exist $\shp$-complete functions that can be efficiently approximated as they admit FPRAS; for instance, there exist FPRAS for the problems of counting the number of satisfying assignments of a DNF propositional formula \cite{KL83} and the number of perfect matchings of a bipartite graph \cite{JSV04}. A key observation here is that if a $\shp$-complete function admits an FPRAS, then its associated decision problem is in the randomized complexity class $\bpp$ (Bounded-Error Probabilistic Polynomial-Time \cite{G77}). Hence, under the widely believed assumption that  $\np \not\subseteq \bpp$, we cannot hope for an FPRAS for a function in $\shp$ whose decision counterpart is $\np$-complete, and we have to concentrate on the class of counting problems with easy decision versions (in $\bpp$ or in a lower complexity class such as $\ptime$). 
%The importance of the class counting problems with easy decision counterparts has motivated the search of robust classes of functions in $\shp$ with this property \cite{PagourtzisZ06}. But the key question here is what should be considered a {\em robust} class. A first desirable condition is that the class has a syntactic definition that allows for the existence of natural complete problems \cite{P94}. Special attention has to be paid here to the notion of reduction used for completeness. Notice that under the notion of Cook reduction, originally used in \cite{Valiant79}, the problems $\cdnf$ and $\csat$ are $\shp$-complete. However, $\cdnf$ has an easy decision counterpart and admits an FPRAS, while $\csat$ does not satisfy these conditions unless $\ptime = \np$. Hence a more strict notion of reduction has to be considered; in particular, the notion of parsimonious reduction (to be defined later) satisfy that if a function $f$ is parsimoniously reducible to a function $g$, then $L_g \in \ptime$ implies that $L_f \in \ptime$ and the existence of an FPRAS for $g$ implies the existence of a FPRAS for $f$. 
%A second desirable condition has to do with the closure properties satisfied by the class, which is a common theme when studying function complexity classes \cite{OH93,FH08}. As in the cases of $\ptime$ and $\np$ that are closed under intersection and union, we expect our class to be closed under multiplication and sum; in fact, if $f$ and $g$ are counting functions with easy decision versions, then we clearly expect $f + g$ and $f \cdot g$ to have easy decision counterparts. For a more elaborated closure property, assume that $\textit{sat\_one}$ is a function that returns one plus the number of satisfying assignments of a propositional formula. Clearly $\textit{sat\_one}$ is a $\shp$-complete function whose decision counterpart $L_{\textit{sat\_one}} = \{ \varphi \mid \textit{sat\_one}(\varphi) > 0 \}$ is trivial. But should $\textit{sat\_one}$ be part of a robust class of counting function with easy decision versions? The key insight here is that if a function in $\shp$ has an easy decision counterpart $L$, then as $L \in \np$ we expect  to have a polynomial-time algorithm that verifies whether $x \in L$ by constructing witnesses for $x$. As an example of this considered all the counting functions mentioned in the previous paragraphs and, in particular, the decision counterpart of $\cdnf$ that can be solved by explicitly constructing in polynomial-time a satisfying assignment for an input propositional formula. Moreover, if such an algorithm for constructing witnesses exists, then we also expect to be able to manipulate such witnesses and in some cases to remove them. In other words, we expect a robust class $\CC$ of counting functions with easy decision versions to be closed under subtraction by one, that is, if $g \in \CC$, then the function $g \dotdiv 1$ should also be in $\CC$, where $(g \dotdiv 1)(x)$ is defined as $g(x) - 1$ if $g(x) \geq 1$, and as $0$ otherwise. Notice that, unless $\ptime = \np$, no such class can contain the function $\textit{sat\_one}$ because $\textit{sat\_one} \dotdiv 1$ counts the number of satisfying assignments of a propositional formula. 


%Interestingly, we show that fragments of QSO naturally captures classes like $\shp$, $\fp$ and $\fpspace$ among others. 



%\cristian{Aqui va la intro de FONDECYT}
%
%Solving a decision problem $L$ means verifying, given an input $x$, whether $x$ belongs to $L$. For example, if $\text{PATH}$ is the reachability problem for directed graphs, then an algorithm for solving $\text{PATH}$ receives as input a string $x = (s,t,G)$, where $G$ is the string representation of a directed graph and $s$, $t$ are the string representations of two nodes in $G$, and it returns {\it true} if there exists a paths from $s$ to $t$ in $G$ (that is, if $x \in L$), and {\it false} otherwise. The complexity of a decision problem is usually measured in terms of the time, or space, needed to solve it. For example, we say that $\text{PATH}$ can be solved in linear time as there exists an algorithm that solves $\text{PATH}$ and works in linear time in the size of the input.% \cite{CLRS09}.
%
%The goal of descriptive complexity is not measuring the complexity of a problem in terms of the time, or space, needed to solve it, but instead measuring this complexity in terms of the logical constructors needed to express it \cite{I99,G07}. 
%More specifically,  
%the main objective of descriptive complexity is to understand how a problem can be defined in a mathematical logic, and whether a complexity class, or set of problems, can be characterized in terms of the properties definable in a mathematical logic. The starting point of this branch of complexity theory is Fagin's theorem \cite{F74}, which states that $\np$ is equal to existential second-order logic ($\eso$), that is, every decision problem in $\np$ can be defined by a sentence in $\eso$, and every sentence in $\eso$ defines a decision problem in $\np$. Since then, many more complexity classes have been characterized in terms of the properties definable in a logic (see \cite{G07} for a survey on this area). 
%Most notably, the class $\ptime$ of all problems that can be solved in polynomial time was shown to be equal to first-order logic extended with a least fixed point operator \cite{V82,I86} and also to some fragments of second-order logic \cite{G92}, provided that a linear order on the domain of the input is available.
%
%The work on descriptive complexity has found a variety of applications. In the area of databases, it has been instrumental in improving our understanding of query languages, as the design of such languages has been guided by the study of logic in different data models such as relational databases \cite{AHV95,GMUW09}, XML \cite{M05}, RDF \cite{PS08,PAG09,HS13} and graph databases \cite{B13,RWE15}.
%In particular, the design of expressive query languages that can be evaluated efficiently, in terms of time and/or space, has taken advantage of the study of the logical definability of the problems in $\ptime$ \cite{V82,I86,ACY91,G92}, as well as of the characterizations of lower complexity classes such as nlog and dlog in terms of logic \cite{I87,I88,G92}. 
%In the area of computational complexity, it has helped us in gaining new insights into the definitions of complexity classes and, in particular, it has given us new tools for the fundamental and difficult problem of separating complexity classes \cite{AV95,I99,L04,G07}. 
%In the area of algorithms, descriptive complexity and, in particular, Fagin's theorem was the key ingredient to define the class MAXSNP of optimization problems \cite{PY91}, which was later shown to be a fundamental class in the study of hardness of approximation \cite{ALMSS98,V04}. 
%It is important to mention here that the definition of MAXSNP would not have been possible without the machine-independent point of view of descriptive complexity, as pointed out by Papadimitriou and Yannakakis in \cite{PY91}.
%
%%Optimization problems differ from decision problems in that the optimum value (maximum or minimum) of an objective function has to be computed. More generally, solving a function problem means computing, given an input $x$, the value of a particular function $f$ on $x$. For example, if $f(x)$ is the length of a string over the alphabet $\{0,1\}$, then an algorithm for solving $f$ receives as input a string $x$ over the alphabet $\{0,1\}$, and returns the length of $x$.
%%\cristian{De nuevo, el ejemplo es muy sencillo. Que tal camino en grafos?}
%%As for the case of decision problems, the complexity of a function problem is usually measured in terms of the time, or space, needed to solve it.
%%\cristian{Este parrafo esta raro. Uno piensa que vas ha hablar sobre problemas de optimización y terminas hablando sobre problemas de computación. Yo cambiaría la primera linea.}
%
%Function problems differ from decision problems in that the value of a  function has to be computed. Thus, solving a function problem means computing, given an input $x$, the value of a particular function $f$ on $x$. For example,
%if we consider the problem $\#\text{PATH}$ of counting the number of paths in a directed graph, then an algorithm for solving $\#\text{PATH}$ receives as input a string $x = (s,t,G)$, where $G$ is the string representation of a directed graph and $s$, $t$ are the string representations of two nodes in $G$, and it returns the number of paths from $s$ to $t$ in $G$.\footnote{If there exists a path from $s$ to $t$ in $G$ that contains a cycle, then this algorithm returns $\infty$ to indicate that there exists an infinite number of paths from $s$ to $t$ in $G$. Otherwise, it return the exact number of paths from $s$ to $t$ in $G$.}  As for the case of decision problems, the complexity of a function problem is usually measured in terms of the time, or space, needed to solve it. For instance, we say that the problem $\#\text{PATH}$ can be solved in polynomial time as there exists an algorithm that solves $\#\text{PATH}$ and works in polynomial time in the size of the input.
%
%The study  of function problems has given rise to a rich theory of function complexity classes \cite{HV95,F97,HO02,AB09}. Some of these classes are natural counterparts of some classes of decision problems; for example, $\fp$ is the class of all functions that can be computed in polynomial time, the natural counterpart of $\ptime$. However, other function complexity classes have emerged from the need to understand the complexity of some function problems for which little can be said if their decision counterparts are considered. In particular, the function complexity class $\shp$ was introduced in \cite{V79a} for this purpose. 
%%Most notably, the function complexity class $\shp$ was introduced in \cite{V79a} to prove that computing the permanent of a square matrix is a difficult problem. 
%A function $f$ is said to be in $\shp$ if there exists a nondeterministic Turing machine $M$ running in polynomial time such that $f(x)$ is the number of accepting runs of $M$ with input $x$. A prototypical example of a problem in $\shp$ is $\#\text{SAT}$, the problem of counting the number of satisfying assignments of a given propositional formula. Obviously, $\#\text{SAT}$ is as difficult as the problem $\text{SAT}$ of verifying whether a propositional formula is satisfiable; in fact, $\#\text{SAT}$ is a $\shp$-complete problem \cite{V79b}. 
%%Thus, the problems in $\shp$ can be considered at least as difficult as the problem in $\np$, as, for example, counting the number of satisfying assignments of a propositional formula $\varphi$ is at least as difficult as verifying whether there exists a satisfying assignments for $\varphi$. 
%
%A proof of $\shp$-completeness for a function problem $L$ is considered as a proof of hardness of $L$. Since the definition of $\shp$ in  \cite{V79a}, many counting problems have been proved to be $\shp$-complete \cite{V79b,PB83,P86,L86,BW91,HMRS98,BW05,DS12,PS13,PS14}. More interesting, this class has been used to prove that this happens even for function problems for which their decision counterparts can be solved efficiently. For example, it can be checked in polynomial time, given a graph $G$ and two nodes $s$, $t$ in $G$, whether the exists a path without repeated nodes from $s$ to $t$ in $G$, which is called a simple path from $s$ to $t$ in $G$. However, the problem $\#\text{SIMPLE-PATH}$ of counting the number of simple paths from a node $s$ to a node $t$ in a graph is $\shp$-complete \cite{V79b}. 
%Other problems in this category include counting the number of perfect matchings of a bipartite graph \cite{V79a} and counting the number of Eulerian cycles in an undirected  graph \cite{BW05}.
%
%Although function problems play a prominent role in computational complexity, descriptive complexity for this type of problems has not been systematically studied and it is not as developed as for the case of decision problems. Insightful characterizations of $\shp$ and some of its extensions have been provided \cite{SST95,B95,CG96}. However, these characterizations do not define function problems in terms of a logic, but instead in terms of some counting problems associated to a logic. Thus, it is not clear how these characterizations can be used to provide a general descriptive complexity framework for function complexity classes.  It should be mentioned that logical definability has also been studied for the case of optimization problems \cite{KT94} and computation over the real numbers \cite{GM95}. As for the previous cases, it is not clear how these approaches can be extended to provide logical characterizations of a variety of function complexity classes. 
%
%%descriptive complexity has not been systematically studied for the case of function complexity classes, with the notable exceptions of \cite{KT94,SST95,B95,CG96}. It should be mentioned that the importance of $\shp$ was also recognized in this area, as some of the few results about descriptive complexity for function complexity classes are characterizations based on logic of $\shp$ \cite{SST95} and some of its extensions \cite{CG96}.
%%\icristian{Aqui yo dejaría claro que los estudios preeliminares sobre lógica descriptiva de funciones de conteo usan conteo de asignaciones para contar en lógica, pero no usan una lógica como tal. Esta explicación te va a servir para explicar mejor el first specific goal.}
%
%The general goal of this project is to develop a descriptive complexity theory for function complexity classes. 
%%\cristian{Este general goal es quizas muy general.}
%To this end, our first specific goal is to develop an appropriate logical framework for function complexity classes, where the result of evaluating a formula over a structure is an arbitrary value instead of the classical values {\it true} and {\it false} in first-order logic. It is important to notice that this framework has to account for the different types of results that can be obtained by evaluating a function; for example,  a function in a class such as $\fp$ can return an arbitrary value, 
%while a function in a counting complexity class such as $\shp$ can only return a natural number. Moreover, this framework has to take into consideration the different types of operators that are allowed in function complexity classes. For instance, the class $\shp$ is closed under addition and multiplication, but it is believed not to be closed under proper subtraction\footnote{The proper subtraction of functions $f$ and $g$ is defined as a function $h$ such that, $h(x) = f(x) - g(x)$ if $f(x) \geq g(x)$, and $h(x) = 0$ otherwise.} and integer division~\cite{FH08}. 
%
%%in a given complexity class,
%%\cristian{esta última sentencia no suena coherente.}
%%as well as for the different types of operators that are allowed in function complexity classes. For example, a function in a class such as $\fp$ can return an integer number, 
%%while a function in a counting complexity class such as $\shp$ can only return a natural number. Moreover, the class $\shp$ is closed under addition and multiplication, but it is believed not to be closed under proper subtraction\footnote{The proper subtraction of $f(x)$ and $g(x)$ if defined as $f(x) - g(x)$ if $f(x) \geq g(x)$, and as 0 otherwise.} and integer division~\cite{FH08}. 
%%\cristian{¿Que tiene que ver esta última oración con lo anterior?}
%
%Our second specific goal is to show that the logical framework is appropriate to develop a descriptive complexity theory for function complexity classes. More specifically,  we plan to restate, as a proof of concept, the results already obtained in the area in terms of our logical framework, to show that it is general enough to provide a unified view of these results. Moreover, we plan to obtain logical characterizations of some of the fundamental function complexity classes, which will include $\fp$ and some function complexity classes requiring polynomial space \cite{L89}. 
%%\cristian{Yo colocaría un punto aparte acá.}
%
%Finally, our third specific goal is to take advantage of the machine-independent point of view of descriptive complexity to improve the understanding of the complexity class $\shp$. As pointed out above, $\shp$ has been used to show that some counting problem are difficult, generally by proving that these problem are $\shp$-complete. But these difficult problems have different characteristics and, in fact, they are even shown to be hard for $\shp$ by using different notions of reduction such as Cook reductions, subtractive reductions and parsimonious reductions \cite{V79a,P99,DHK05}. As our third specific goal, we plan to improve the understanding of two of these distinctive features by using descriptive complexity tools. More specifically, we plan to obtain robust syntactic definitions of classes of counting problem in $\shp$ whose associated decision problems can be efficiently solved \cite{P01,PZ06}, and we plan to identify sub-classes of $\shp$ whose counting problems have good properties in terms of approximations. 
%%\cristian{No es necesario decir ``randomized'' acá. Approximation siempre incluye randomized.}
%
%In what follows, we describe in detail the steps of this project, including the necessary background about function complexity classes and descriptive complexity. 
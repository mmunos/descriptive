There are counting complexity classes that do not fit in our framework because either the output of a function in not a natural numbers (e.g. a negative number) or the class is not defined purely in terms of arithmetical operations (e.g. min and max).
To remedy this problem, we show here how to easily extend $\qso$ in order to capture these classes that go beyond our logical framework. 

It is well-known that $\shp$ is not closed under subtraction, not either closed under subtraction by one, by some complexity-theoretical assumption~\cite{OH93}.
To overcome this issue, people introduced the class $\gp$~\cite{fenner1994gap} defined as the class of functions $f$ such that for some non-deterministic polynomial time Turing machine, $f(x)$ is the number of accepting runs minus the number of rejecting runs.
That is, $\gp$ is the closure of $\shp$ functions under subtraction and, by definition, it can compute negative values. 

Given that our logical framework was built on top of non-negative values, we need to extend $\qso$ in order to describe functions in $\gp$. 
The most elegant way to do this is by allowing constants coming from $\bbZ$ instead of just $\bbN$. 
Formally, we define the logic $\qsoz$ whose syntax is the same as in (\ref{syntax}) and semantics is the same as in Table~\ref{tab-semantics} except that constant $s$ come from $\bbZ$.  
Similar than for $\qso$, we define the fragment $\eqsoz$ as the extension of $\eqso$ with negative constants.
\begin{example}
	Recall the setting of Example~\ref{ex:cliques} and suppose now that we want to compute the number of cliques in a graph that are not triangles. Then this can be easily done in $\qsoz$ with the following formula:
	\[
	\alpha_4 := \alpha_2 + (-1) \cdot \alpha_1 
	\]
\end{example}
Adding negative constants is a mild extension to allow subtraction in the logic. 
In fact, this is what we need to capture classes like $\gp$.
\begin{proposition} \label{prop:capture-gapp}
	$\eqsoz(\fo)$ captures $\gp$ over ordered structures.
\end{proposition}
The previous result can be proved straightforward from the characterization of $\shp$ and the definition of $\gp$. 
However, we believe that this is a relevant result for showing how robust is $\qso$ in order to capture diverse complexity classes.

An interesting class of functions in complexity theory comes from considering the optimization version of a decision problem. For example, one can define MAX-SAT as the problem of determining the maximum number of clauses, of a given CNF formula, that can be made true by an assignment. Here, the problem is defined in terms of a maximization function and it is not known how to define this kind of function in $\shp$. 
To formalize this set of optimization problems, in~\cite{krentel1988complexity} the class $\optp$ was introduces as the class of functions computable by taking the maximum or minimum of the output values over all runs of a non-deterministic polynomial time machine with output (i.e. each run produces a binary string which is interpreted as a number). 
For instance, MAX-SAT is in $\optp$ with several other optimization version of $\np$-problems.
Given that in~\cite{krentel1988complexity} the author do not make the distinction between $\max$ or $\min$, in 
Given that 
 

\begin{multline}
\alpha := \beta \ \mid \ s \ \mid \ (\, \max\{\alpha,\alpha\} \,) \ \mid\ (\, \min\{\alpha,\alpha\} \,) \ \mid \\ \maxa{x} \alpha \ \mid \ \mina{x} \alpha \ \mid \ \maxa{X} \alpha \ \mid \ \mina{X} \alpha 
\end{multline}
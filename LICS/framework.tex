%!TEX root = main.tex

We introduce here the logic framework that we use for studying counting complexity classes. 
This logic framework is based on the framework of Weighted Logics~\cite{DrosteG07} (WL) that has been used in the context of weighted automata for studying functions from words (or trees) to semirings. 
We propose here to use the framework of WL over any relational structure and to restrict the semiring to natural numbers. 
The extension to any relational structure will allow us to study general counting complexity classes and the restriction to the natural numbers will simplify the notation in this context (see Section~\ref{sec:previous} below for a more detailed discussion).

Given a relational signature $\R$, the set of Quantitative Second-Order logic formulas (or just $\qso$-formulas) over $\R$ is given by the following grammar:
%\[
%\begin{array}{rcl}
%\alpha & := & \varphi \ \mid \ s \ \mid \ (\alpha \add \alpha) \ \mid\ (\alpha \mult \alpha) \ \mid \ \\
%& &  \sa{x} \alpha \ \mid \pa{x} \alpha \ \mid \ \sa{X} \alpha \ \mid \ \pa{X} \alpha 
%\end{array}
%\]
\begin{multline*}
\alpha := \varphi \ \mid \ s \ \mid \ (\alpha \add \alpha) \ \mid\ (\alpha \mult \alpha) \ \mid \\ \sa{x} \alpha \ \mid \ \pa{x} \alpha \ \mid \ \sa{X} \alpha \ \mid \ \pa{X} \alpha 
\end{multline*}
where $\varphi$ is an $\so$-formula over $\R$, $s \in \bbN$, $x \in \fv$ and $X \in \sv$. If $\R$ is not mentioned, $\qso$ refers to the union of the sets of $\qso$ formulas over $\R$, for every relational signature~$\R$.
 
Note that the syntax of QSO formulas is divided in two levels. 
The first level is composed by $\so$-formulas over $\R$ (called boolean formulas) and the second level is made by counting operators of addition and multiplication. 
For this reason, the quantifiers in $\so$ (e.g. $\exists x$ or $\exists X$) are called boolean quantifiers and the quantifiers that make use of addition and multiplication (e.g. $\Sigma x$ or $\Pi X$) are called {\em quantitative quantifiers}.
Furthermore, $\Sigma x$ and $\Sigma X$ are called first- and second-order sum, and $\Pi x$ and $\Pi X$ the first- and second-order product, respectively.
This division between boolean and quantitative levels is essential for understanding the difference between the logic and the quantitative part. 
Furthermore, this will allow us later to parametrize both levels of the logic in order to capture different counting complexity classes.

Let $\R$ be a relational signature, $\A$ be an ordered finite $\R$-structure with domain $A$, $v$ a first-order assignment for $\A$ and $V$ a second-order assignment for $\A$. Then the \emph{evaluation} of a $\qso$-formula $\alpha$ over $(\A, v, V)$ is defined as a function $\sem{\alpha}$ that on input $(\A, v, V)$ returns a number in $\bbN$. Formally, the function $\sem{\alpha}$ is recursively defined in Table~\ref{tab-semantics}.
\begin{table}
	\addtolength{\jot}{0.5em}
	\begin{align*}
	\sem{\varphi}(\A, v, V) & = 
	\begin{cases}
	1 & \mbox{if } (\A, v, V) \models \varphi \\
	0 & \mbox{otherwise}
	\end{cases}\\
	\sem{s}(\A, v, V) & = s \\
	\sem{\alpha_1 \add \alpha_2}(\A, v, V) & = \sem{\alpha_1}(\A, v, V) + \sem{\alpha_2}(\A, v, V)\\
	\sem{\alpha_1 \mult \alpha_2}(\A, v, V) & = \sem{\alpha_1}(\A, v, V) \cdot \sem{\alpha_2}(\A, v, V)\\ 
	\sem{\sa{x} \alpha}(\A, v, V) & = \displaystyle \sum_{a \in A} \sem{\alpha}(\A,v[a/x],V)\\
	\sem{\pa{x} \alpha}(\A, v, V) & = \displaystyle \prod_{a \in A} \sem{\alpha}(\A,v[a/x],V)\\
	\sem{\sa{X} \alpha}(\A, v, V) & = \displaystyle \sum_{B \subseteq A^{\arity(X)}} \sem{\alpha}(\A, v, V[B/X])\\
	\sem{\pa{X} \alpha}(\A, v, V) & = \displaystyle \prod_{B \subseteq A^{\arity(X)}} \sem{\alpha}(\A, v, V[B/X])
	\end{align*}
	\caption{The semantics of QSO formulas.}
	\label{tab-semantics}
	\vspace*{-20pt}
\end{table}
%$$
%\renewcommand{\arraystretch}{1.7}
%\begin{array}{rcl} 
%\sem{\varphi}(\A, v, V) & = & 
%\begin{cases}
%1 & \mbox{if } (\A, v, V) \models \varphi \\
%0 & \mbox{otherwise}
%\end{cases}\\
%\sem{s}(\A, v, V) & = & s \\
%\sem{\alpha_1 \add \alpha_2}(\A, v, V) & = & \sem{\alpha_1}(\A, v, V) + \sem{\alpha_2}(\A, v, V)\\
%\sem{\alpha_1 \mult \alpha_2}(\A, v, V) & = & \sem{\alpha_1}(\A, v, V) \cdot \sem{\alpha_2}(\A, v, V)\\ 
%\sem{\sa{x} \alpha}(\A, v, V) & = & \displaystyle \sum_{a \in A} \sem{\alpha}(\A,v[a/x],V)\\
%\sem{\pa{x} \alpha}(\A, v, V) & = & \displaystyle \prod_{a \in A} \sem{\alpha}(\A,v[a/x],V)\\
%\sem{\sa{X} \alpha}(\A, v, V) & = & \displaystyle \sum_{B \subseteq A^{\arity(X)}} \sem{\alpha}(\A, v, V[B/X])\\
%\sem{\pa{X} \alpha}(\A, v, V) & = & \displaystyle \prod_{B \subseteq A^{\arity(X)}} \sem{\alpha}(\A, v, V[B/X])
%\end{array}
%$$
A $\qso$-formula $\alpha$ is said to be a \emph{sentence} if it does not have any free variable, that is, every variable in $\alpha$ is under the scope of a usual quantifier or a quantitative quantifier. It is important to notice that if $\alpha$ is a $\qso$-sentence over a relational signature $\R$, then for every ordered finite $\R$-structure $\A$, first-order assignments $v_1$, $v_2$ for $\A$ and second-order assignments $V_1$, $V_2$ for $\A$, it holds that $\sem{\alpha}(\A, v_1, V_1) = \sem{\alpha}(\A, v_2, V_2)$.
Thus, in such a case we use the term $\sem{\alpha}(\A)$ to denote $\sem{\alpha}(\A, v, V)$, for some arbitrary first-order assignment $v$ for $\A$ and some arbitrary second-order assignment $V$ for $\A$. 
\begin{example}
Let $\bG = \{E(\cdot,\cdot)\}$ be the vocabulary for graphs and $\fG$ be an ordered finite $\bG$-structure encoding a non-directed graphs. 
Suppose that we want to count the number of triangles in $\fG$. Then this can be defined with the following QSO-formula:
\begin{multline*}
\alpha_1 \ := \ \sa{x} \sa{y} \sa{z} ( E(x,y) \, \wedge \, E(y,z) \, \wedge \, E(z,x) \, \wedge \\
x \leq y \, \wedge \, y \leq z )
\end{multline*}
For $\alpha_1$ we encode a triangle as an increasing sequence of nodes $\{x, y, z\}$ in order to count each triangle once. Then the boolean subformula  $E(x,y) \wedge E(y,z) \wedge E(z,x) \wedge
x \leq y \wedge y \leq z$ is checking the triangle property, by outputting $1$ if $\{x, y, z\}$ forms a triangle in $\fG$ and $0$ otherwise.
Finally, the sum quantifiers in $\alpha_1$ aggregates all the values, counting the number of triangles in $\fG$.

Suppose now that we want to count the number of cliques in~$\fG$ (i.e. set of nodes where every pair of nodes is connected). We can easily define this function with the following formula:
$$
\alpha_2 := \sa{X} \big( \, \fa{x} \fa{y} \left(X(x) \wedge X(y)\right) \rightarrow E(x,y) \, \big)  
$$ 
Similar than for $\alpha_1$, in the boolean subformula of $\alpha_2$ we check whether $X$ is a clique and with the sum quantifier we add one for each clique in $\fG$. 
Note here that, in contrast to $\alpha_1$, in $\alpha_2$ we need a second-order quantifier in the quantitative level.
This is according to the inherent complexity of evaluating each formula: $\alpha_1$ defines an $\fp$ function where $\alpha_2$ defines a $\shp$-hard function~\cite{paper-that-shows-that-this-problem-is-sharpP-hard}.
\end{example}
\begin{example}
For a more involved example that includes multiplication, let $\bM = \{M(\cdot,\cdot)\}$ be the vocabulary for matrices where a structure $\fM$ over $\bM$ encodes a 0-1 matrix $A$ where $M(i,j)$ is true if $A_{i,j} = 1$ and $0$ otherwise. 
Suppose now that we want to compute the permanent of an $n$-by-$n$ 0-1 matrix $A$ which is defined by:
$$
\op{perm}(A) \; = \; \sum_{\sigma \in S_n} \prod_{i=1}^n A_{i, \sigma(i)}  
$$
where $S_n$ is the set of all permutations over $\{1, \ldots, n\}$.
The permanent is a relevant matrix function that has found many applications in different areas~\cite{permanent-applications} and it was one of the first function that was shown to be difficult for counting~\cite{Valiant79} (i.e. $\shp$-complete). 
For a binary relation symbol $S$, let $\op{permut}(S)$ be the $\fo$-formula that is true iff $S$ is a permutation, i.e. bijective function (the definition of $\op{permut}(S)$ is straightforward).
Then a $\qso$-formula for defining the permanent of a matrix is as follows:
\[
\alpha_3 := \sa{S} \op{permut}(S) \cdot \pa{x} (\ex{y} S(x,y) \wedge M(x,y))
\]
Intuitively, the subformula $\beta(s) := \pa{x} (\ex{y} S(x,y) \wedge M(x,y))$ calculates the value $\prod_{i=1}^n A_{i, \sigma(i)}$ whenever $S$ encodes a permutation $\sigma$.
Then the subformula $\op{permut}(S) \cdot \beta(S)$ computes $\beta(S)$ when $S$ is a permutation and $0$ otherwise (i.e. $\op{permut}(S)$ behaves like a filter). 
Finally, the second order sum aggregates these values iterating over all binary relations and calculating the permanent of the matrix.
We would like to end this example by highlighting the similarity of $\alpha_3$ with the permanent formula. 
Indeed, an advantage of $\qso$-formulas is that the first- and second-order quantifiers naturally reflect the operations used to define mathematical formulas in practice.
\end{example}

We consider several fragments of $\qso$, which are obtained by restricting the syntax of the boolean formulas or the use of the quantitative quantifiers.
In this direction, we denote by $\qfo$ the fragment of $\qso$ where second-order sum and product are not allowed. 
For example, $\alpha_1$ is in $\qfo$ and $\alpha_2$ is not.
Another interesting fragment are the formulas of $\qso$ where only sum operators and quantifiers are allowed. 
Formally, we denote by $\eqso$ the fragment of $\qso$ where first- and second-order products (i.e. $\pa{x}$ and $\pa{X}$) are not allowed.
For example, $\alpha_1$ and $\alpha_2$ are formulas of $\eqso$ but $\alpha_3$ is not. 
We also consider fragments of $\qso$ by further restricting the boolean core of the logic.
Let $\LL$ be a fragment of $\so$.
We define the quantitative logic $\qso(\LL)$ to be the fragment of $\qso$ obtained by restricting $\varphi$ to be a formula in $\LL$. 
In general, if $\FF$ is a fragment of $\qso$ we define $\FF(\LL)$ to be the fragment of $\FF$ obtained by restricting boolean formulas to $\LL$.
For example, we can define the fragments $\qfo(\fo)$ or $\eqso(\fo)$ which are subfragments of $\qfo$ and $\eqso$ where $\varphi$ is restricted to $\fo$ formulas. 

In the next section, we variate $\FF$ and $\LL$ to capture several counting complexity classes. Before this, we devote the next subsection to show the connection of $\qso$ with previous frameworks for defining functions over relational structures.

\subsection{Previous frameworks for quantitative functions} \label{sec:previous}

In this subsection we discuss previous frameworks proposed in the literature and how they differ to our approach.
We start by discussing the connection between $\qso$ and weighted logics (WL)~\cite{DrosteG07}. 
As it was previously discussed, $\qso$ is a fragment of WL.
The real difference is that we restrict the semiring used in WL to natural numbers in order to study counting complexity classes.
Another difference of WL with our approach is that, as far as we know, this is the first paper to study weighted logics over general signature properly to do descriptive complexity of counting classes. 
Previous works on WL usually restrict the signature of the logic to strings, trees, and other specific structures (see \cite{droste2009handbook} for more examples), and did not study the logic over general structures. 
Furthermore, in this paper we propose further extensions for $\qso$ (see Section~\ref{sec:beyond}) which start to differ from previous approaches in WL.

Another approach that resembles $\qso$ are counting logics~\cite{L04,counting-paper-here}. 
Logics with counting operators usually extend $\fo$ with quantifiers that counts how many ways can be satisfied a formula over a second sort (i.e. natural numbers). 
In contrast to our approach, counting operators are usually used for checking boolean properties over structures and not for outputting values (i.e. they do not define a function).
Although there are some papers that uses this operator for counting~\cite{XXX}, they have not used the logic for capturing counting complexity classes.

Finally, the work on~\cite{SalujaST95} and \cite{Gradel91} is of particular interest for our work. 
In~\cite{SalujaST95}, it was proposed to define functions over structures by using open variables on SO-formulas and count how many extensions of the structure satisfy the formula (i.e. by instantiating the open variables). 
Formally, Saluja et. al \cite{SalujaST95} define a family of counting classes $\#\LL$ for each fragment $\LL$ of $\so$. For a formula $\varphi(\bar{x},\bar{X})$ over $\R$, the function $f_{\varphi(x,X)}$ is defined as
$
f_{\varphi}(\A) = \vert \{\langle \bar{a},\bar{A} \rangle\mid \A\models\varphi(\bar{a},\bar{A})\}\vert.
$
for each $\A\in\ostr[\R]$. Then a function $g:\ostr[\R]\to\nat$ is in $\#\LL$ if there exists an formula $\varphi(\bar{x},\bar{X})$ in $\LL$ such that $f = f_{\varphi}$. 
In~\cite{SalujaST95}, it was shown several results for capturing counting complexity classes which are relevant for our work. We discuss and use these results in Sections~\ref{sec:complexity} and~\ref{sec:syntactic}.
Note that for any formula $\varphi(\bar{x},\bar{X})$ it holds that $f_\varphi \equiv \sem{\sa{\bar{X}} \sa{\bar{x}} \varphi(\bar{x},\bar{X})}$, that is, the approach in \cite{SalujaST95} can be seen as a syntactical restriction of $\qso$. 
Thus, the advantage of our approach relies on the flexibility of defining  counting functions by alternating sum with product operators or, moreover, by introducing new quantitative operators (like in Section~\ref{sec:beyond}).
Furthermore, in the next section we show how to capture some interesting classes that could never be captured by following the approach in~\cite{SalujaST95}.

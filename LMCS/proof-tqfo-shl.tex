$\boldsymbol{\tqfo(\fo)}$ {\bf can be computed in} $\boldsymbol{\shl.}$
Let $\R$ be some relational signature. Let $\alpha$ be a formula in $\tqfo(\fo)$. We will construct a nondeterministic logspace algorithm $M_{\alpha}$ that on input $\enc(\A)$, where a first-order assignment $v$ is being stored in memory, accepts in $\sem{\alpha}(\A,v)$ paths. Suppose the domain of $\A$ is $A = \{1,\ldots,n\}$. The algorithm needs $c\mult\log_2(n)$ bits of memory to store $v$, where $c$ is the total number of first-order variables in $\alpha$. If $\alpha = \varphi$, we check if $(\A,v)\models\varphi$ in deterministic logarithmic space, and accept if and only if it does. If $\alpha = s$, we generate $s$ branches and accept in all of them. If $\alpha = (\alpha_1 + \alpha_2)$, we simulate $M_{\alpha_1}$ and $M_{\alpha_2}$ on separate branches. If $\alpha = (\alpha_1\mult\alpha_2)$, we simulate $\alpha_1$ and if it accepts, instead of doing so, we simulate $\alpha_2$. If $\alpha = \sa{x}\beta$, for each $a\in A$ we generate a different branch where we simulate $M_{\beta}$ while storing $v[a/x]$. If $\alpha = \pa{x}\beta$, we simulate $M_{\beta}$ while storing $v[1/n]$, and on each accepting branch, instead of accepting we replace the assignment on $x$ to 2, to simulate $M_{\beta}$ while storing $v[2/x]$, and so on. If $\alpha = [\pth \varphi(\bar{x},\bar{y})]$ where $\varphi$ is an $\fo$ formula, we simulate the $\shl$ procedure that counts the number of paths for a graph of a given size. This procedure starts by setting $\bar{a} = v(\bar{x})$. On each iteration, nondeterministically chooses an assignment $\bar{a}$ for $\bar{x}$, continues if $(\A,v)\models\varphi(\bar{a}',\bar{a})$ where $\bar{a}'$ is the previously chosen value for $\bar{a}$, and rejects otherwise. If at any point we obtain that $\bar{a} = v(\bar{y})$, we generate an accepting branch, and continue simulating the procedure in the current branch. We simulate $n^{\length{\bar{x}}}$ iterations of the procedure, and this generates exactly $\sem{[\pth \varphi(\bar{x},\bar{y})]}(\A,v)$ accepting branches. This ends the construction of the algorithm. Consider $f$ as the $\shl$ function associated to this procedure and we have that for each finite $\R$-structure $\A$: $f(\enc(\A)) = \sem{\alpha}(\A)$.

\vspace{1em}
$\boldsymbol{\shl}$ {\bf can be modelled in }$\boldsymbol{\tqfo(\fo).}$ Let $f$ be a function in $\shl$ and let $M$ be a nondeterministic logspace machine such that $\acc_{M}(\enc(\A)) = f(\enc(\A))$. We assume that $M$ has only one accepting state and upon accepting it immediately stops. Moreover, we assume that there exists only one accepting configuration altogether. We make use of transitive closure logic ($\tc$) to simplify our proof~\cite{G07}. We have that $\tc$ captures $\nlog$\cite{I83}, so there exists a formula such that $\A\models\varphi$ if and only if $M$ accepts $\enc(\A)$. This formula can be expressed as:
$$
\varphi = \exists\bar{u}\exists\bar{z}(\first(\bar{u})\wedge \psi_{\bf acc}(\bar{z})\wedge[{\bf tc}_{\bar{x},\bar{y}}\,\psi_{\bf next}(\bar{x},\bar{y})](\bar{u},\bar{z})),
$$
where $\psi_{\bf acc}(\bar{z})$ is an $\fo$ formula that expresses that $\bar{z}$ is an accepting configuration, and $\psi_{\bf next}(\bar{x},\bar{y})$ is an $\fo$ formula that expresses that $\bar{y}$ is the next configuration from $\bar{x}$~\cite{G07}. Here, there is a 1-1 correspondence between configurations of $M$ and assignments to $\bar{z}$. As a consequence, given a structure $\A$, and a first-order assignment $v$ to $\A$ where $v(\bar{x})$ is the starting configuration and $v(\bar{y})$ is the sole accepting configuration, the value of $\sem{[\pth\psi_{\bf next}(\bar{x},\bar{y})]}(\A,v)$ is equal to $\acc_M(\enc(\A))$.
Finally, we define the $\tqfo(\fo)$ formula
$$
\alpha = \sa{\bar{u}}\sa{\bar{z}}(\first(\bar{u})\mult\psi_{\bf acc}(\bar{z})\mult[\pth \psi_{\bf next}(\bar{u},\bar{z})]),
$$
which satisfies $\sem{\alpha}(\A) = f(\enc(\A))$ for each structure $\A$. This concludes the proof.
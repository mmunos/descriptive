%!TEX root = main.tex

The class $\shp$ was introduced in \cite{Valiant79} to prove that computing the permanent of a matrix, as defined in Example \ref{exa-perm}, is a $\shp$-complete problem.
As a consequence of this result many counting problems have been proved to be $\shp$-complete~\cite{V79b,arora2009computational}.
%\cite{V79b,PB83,P86,L86,BW91,HMRS98,DG00,BW05,DS12, PS13,PS14}.
Among them, problems having easy decision counterparts play a fundamental role, as a counting problem with a hard decision version is expected to be hard. Formally, the decision problem associated to a function $f : \Sigma^* \to \mathbb{N}$ is defined as $L_f = \{ x \in \Sigma^* \mid f(x) > 0 \}$, and $f$ is said to have an easy decision version if $L_f \in \ptime$. 
Many prominent examples satisfy this property, like computing the number of: perfect matchings of a bipartite graph ($\cpm$)~\cite{Valiant79}, satisfying assignments of a DNF ($\cdnf$)~\cite{DHK05,KL83} or Horn ($\chsat$)~\cite{V79b} propositional formula, among others.

Counting problems with easy decision versions play a fundamental role in the search for efficient approximation algorithms for functions in $\shp$. 
A fully-polynomial randomized approximation scheme (FPRAS) for a function $f : \Sigma^* \to \bbN$ is a randomized algorithm $\mathcal{A} : \Sigma^* \times (0,1) \to \bbN$ such that: (1) for every string $x \in \Sigma^*$ and real value $\varepsilon \in (0,1)$, the probability that $|f(x) - \mathcal{A}(x,\varepsilon)| \leq \varepsilon \cdot f(x)$ is at least $\frac{3}{4}$, and (2) the running time of $\mathcal{A}$ is polynomial in the size of $x$ and $1/\varepsilon$ \cite{KL83}. 
Notably, there exist $\shp$-complete functions that can be efficiently approximated as they admit FPRAS; for instance, there exist FPRAS for $\cdnf$~\cite{KL83} and $\cpm$~\cite{JSV04}. 
A key observation here is that if a function $f$ admits an FPRAS, then $L_f$ is in the randomized complexity class $\bpp$~\cite{G77}.
Hence, under the widely believed assumption that  $\np \not\subseteq \bpp$, we cannot hope for an FPRAS for a function in $\shp$ whose decision counterpart is $\np$-complete, and we have to concentrate on the class of counting problems with easy decision versions. That is, with decision versions in P.

The importance of the class of counting problems with easy decision counterparts has motivated the search for robust classes of functions in $\shp$ with this property \cite{PagourtzisZ06}. But the key question here is what should be considered a {\em robust} class. 
A first desirable condition has to do with the closure properties satisfied by the class, which is a common theme when studying function complexity classes \cite{OH93,FH08}. Analogously to the cases of $\ptime$ and $\np$, which are closed under intersection and union, we expect our class to be closed under multiplication and sum. For a more elaborated closure property, assume that $\textit{sat\_one}$ is a function that returns one plus the number of satisfying assignments of a propositional formula. Clearly $\textit{sat\_one}$ is a $\shp$-complete function whose decision counterpart $L_{\textit{sat\_one}}$ is trivial. But should $\textit{sat\_one}$ be part of a robust class of counting functions with easy decision versions? The key insight here is that if a function in $\shp$ has an easy decision counterpart $L$, then as $L \in \np$ we expect  to have a polynomial-time algorithm that verifies whether $x \in L$ by constructing witnesses for~$x$. 
%As an example of this considered all the counting functions mentioned in the previous paragraphs and, in particular, the decision counterpart of $\cdnf$ that can be solved by explicitly constructing in polynomial-time a satisfying assignment for an input propositional formula. 
Moreover, if such an algorithm for constructing witnesses exists, then we also expect to be able to manipulate such witnesses and in some cases to remove them. In other words, we expect a robust class $\CC$ of counting functions with easy decision versions to be closed under subtraction by one, that is, if $g \in \CC$, then the function $g \dotdiv 1$ should also be in $\CC$, where $(g \dotdiv 1)(x)$ is defined as $g(x) - 1$ if $g(x) \geq 1$, and as~$0$ otherwise. Notice that, unless $\ptime = \np$, no such class can contain the function $\textit{sat\_one}$ because $\textit{sat\_one} \dotdiv 1$ counts the number of satisfying assignments of a propositional formula.

A second desirable condition of robustness is the existence of natural complete problems~\cite{P94}. Special attention has to be paid here to the notion of reduction used for completeness. Notice that under the notion of Cook reduction, originally used in \cite{Valiant79}, the problems $\cdnf$ and $\csat$ are $\shp$-complete. However, $\cdnf$ has an easy decision counterpart and admits an FPRAS, while $\csat$ does not satisfy these conditions unless $\ptime = \np$. Hence a more strict notion of reduction has to be considered; in particular, the notion of parsimonious reduction (to be defined later) satisfies that if a function $f$ is parsimoniously reducible to a function $g$, then $L_g \in \ptime$ implies that $L_f \in \ptime$ and the existence of an FPRAS for $g$ implies the existence of a FPRAS for $f$. 

In this section, we use the framework developed in this paper to address the problem of defining a robust class of functions with easy decision versions. More specifically, we use the framework to introduce in Section \ref{sec-hier-shp} a syntactic hierarchy of counting complexity classes contained in $\shp$. Then this hierarchy is used in Section \ref{sec-clo} to define a class of functions with easy decision versions and good closure properties, and in Section \ref{sec-horn} to define a class of functions with easy decision versions and 
natural complete problems.


\subsection{The $\eqso(\fo)$-hierarchy inside $\shp$}
\label{sec-hier-shp}
\input{saluja}

\subsection{Defining a class of functions with easy decision versions and good closure properties}
\label{sec-clo}
\input{syntactic-clo}

\subsection{Defining a class of functions with easy decision versions and natural complete problems}
\label{sec-horn}
\input{syntactic-horn}



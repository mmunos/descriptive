
Assume that $\alpha$ is a sentence in $\qso$. Then slightly abusing notation, we also use $\alpha$ to denote a function from $\R$ to $\bbN$ such that for every $\A \in \str[\R] $:
\begin{eqnarray*}
\alpha(\enc(\A)) & = & \sem{\alpha}(\A).
\end{eqnarray*}
\begin{definition}
Let $\FF$ a fragment of $\qso$, $\CC$ a function complexity class over $\bbN$ and $\KK$ a class of finite structures. Then $\FF$ {\em captures} $\CC$ over $\KK$ if:
\begin{itemize}
\item for every $\alpha$ in $\FF$, there exists $f \in \CC$ such that $\res{\alpha}{\KK} = \res{f}{\KK}$; and

\item for every $f \in \CC$, there exists $\alpha$ in $\FF$ such that $\res{f}{\KK} = \res{\alpha}{\KK}$.
\end{itemize}
\end{definition}
In the previous definition, if $\KK$ is the class of all finite structures, then we say that $\FF$ captures $\CC$ over the class of all structures, and if $\KK$is the class of all ordered finite structures, then we say that $\FF$ captures $\CC$ over the class of ordered structures. 

\cristian{Aca hay que definir esto sobre estructuras finitas directamente. No veo el sentido de tener estructuras infinitas.}

\begin{theorem} \label{captfp}
	$\qfo(\lfp)$ captures $\fp$ over the class of ordered structures.
\end{theorem}
\begin{proof}
	For the first condition, let $\alpha\in\qfo(\lfp)$, $\A\in\ostr$, $v$ and $V$ a first and second order assignment for $\A$, respectively. To evaluate $\sem{\alpha}(\A,v,V)$, we replace each first order sum and first order product by their corresponding expansion. This is, $\Sigma x \beta(x)$ is replaced by $(\beta(a_1)+\cdots+\beta(a_n))$, where $A = \{a_1,\ldots,a_n\}$, and $\Pi x \beta(x)$ is replaced by $(\beta(a_1)\cdot\,\cdots\,\cdot\beta(a_n))$. Then we replace each logic sub-formula $\varphi$ in $\alpha$ by their evaluated value, 0 or 1. Since each of this formulas is in $\lfp$, this can be done in polynomial time. The resulting formula is an arithmetic expression, which can be evaluated recursively in polynomial time.
	
	For the second condition, let $f\in \fp$. Let $k\in\nat$ be such that $\vert f(\A) \vert = \vert A \vert^k$ for each $\A\in\ostr[\R]$. Let $\Phi(x_0,\ldots,x_{k-1})$ be a $\lfp$ formula such that $(\A,a_0,\ldots,a_{k-1})\models\Phi$ if and only if in the string $y = f(\A)$ there is 1 in the $(\vert A \vert^{k-1}m_{k-1} + \cdots + \vert A \vert^2 m_2 + \vert A \vert m_1 + m_0)$-th position from right to left, and where $a_i$ is the (0-indexed) $m_i$-th element of $A$. We use
	$$
	\alpha = \Sigma x_0 \cdots \Sigma x_{k-1} \Phi(x_0,\ldots,x_{k-1})\cdot\varphi_{k-1}(x_{k-1})\cdot\,\cdots\,\cdot\varphi_0(x_0).
	$$
	where $\varphi_i(x) = \Pi y[(y < x)\mapsto\Pi z_1\cdots\Pi z_i\,2]$ for $i > 0$ and $\varphi_0(x) = \Pi y[(y < x)\mapsto 2]$. Note that if $a$ is the  $m$-th element in $A$, then $\sem{\varphi_i(x)}(\A,a) = 2^{\vert A \vert^i m}$. Therefore, for each $(a_0,\ldots,a_{k-1})\in A^k$, we have that $\sem{\Phi(x_0,\ldots,x_{k-1})\cdot\varphi_{k-1}(x_{k-1})\,\cdots\,\varphi_0(x_0)}(\A,a_0,\ldots,a_{k-1}) = 2^{(\vert A \vert^{k-1}m_{k-1} + \cdots + \vert A \vert^2 m_2 + \vert A \vert m_1 + m_0)}$ if $(\A,a_0,\ldots,a_{k-1})\models\Phi$ and 0 otherwise, and adding these values gives $f(\A)$. 	
\end{proof}

\begin{theorem}
	$\qfo(\pfp)$ captures $\nfpspace$ over the class of ordered structures.
\end{theorem}
\begin{proof}
	For the first condition, we use the exact same procedure as in Theorem \ref{captfp}, noting that evaluating each of the $\pfp$ formulas can be done in polynomial space, and that the result is also polynomial on the size of the input.
	
	For the second condition, note that for each function $f\in \nfpspace$, $\vert f(\A) \vert$ is polynomial on $\vert A \vert$. Thus, there is a $\pfp$ formula $\Phi$ that models the string $f(\A)$ by the bit. The rest of the proof is analogous to Theorem \ref{captfp}.
\end{proof}

\begin{theorem}
	$\qfo(\tc)$ captures $\shl$ over the class of ordered structures.
\end{theorem}
\begin{proof}
	For the first condition, let $\alpha\in\qfo(\tc)$, let $\A\in\ostr$ $v$ and $V$ first and second order assignments of $\A$ respectively. We evaluate $\sem{\alpha}(\A,v,V)$ recursively. A logic formula $\varphi$ is evaluated...?
	
	For the second condition, note that for each function $f\in \shl$, $\vert f(\A) \vert$ is polynomial on $\vert A \vert$. Thus, there is a $\tc$ formula $\Phi$ that models the string $f(\A)$ by the bit. The rest of the proof is analogous to Theorem \ref{captfp}.
\end{proof}

\begin{theorem}
	$\rqfo(\fo)$ captures $\fp$ over the class of ordered structures.
\end{theorem}

\begin{theorem}
	$\tqfo(\fo)$ captures $\shl$ over the class of ordered structures.
\end{theorem}
\begin{proof}
	For the second condition, let $f \in \shl$. We will address the case where $\R$ contains only one binary predicate $E$, and the rest of the cases can be deduced from this. Let $M$ be a non-deterministic logspace machine such that $f(\A) = \acc_M(\A)$ for each $\A \in \ostr[R]$. Suppose ${\cal Q} = \{q_1,\ldots,q_{\ell}\}$ is the set of states of $M$, where $q_1$ is the initial state, and $q_{\ell}$ is only final state of $M$. Let $n = \vert A \vert$ and let $w = \enc(\A) \in \{0,1\}^{n^2}$. We assume that $M$ with input $w$ uses space $s_M(w) < c\cdot\log(n)$ and furthermore, $s_M(w) < n-2$. We notate $M(w)$ as the graph of configurations of $M$ running on input $w$.
	
	We represent configurations with a tuple of fixed size $k$. The formula $\varphi(\bar{x},\bar{y})$ describes a procedure that given a configuration generates a possible next configuration. The formula $\varphi_I(\bar{x})$ models that $\bar{x}$ is the initial configuration of $M(w)$. The formula $\varphi_F(\bar{x})$ models that $\bar{x}$ is an accepting (final) configuration of $M(w)$. The formula we construct is:
	$$
	\alpha = \sa{\bar{x}}\sa{\bar{y}}([\pth \varphi(\bar{u},\bar{v})](\bar{x},\bar{y})\cdot \varphi_I(\bar{x})\cdot\varphi_F(\bar{y})).
	$$
	
	To illustrate our idea, we will show a greatly simplified example. Consider a machine $M$ that works in exactly $\log_2(n)$ space and only allows 0 or 1 in the working tape. Consider an input $\A$ of size 16 (that is, $A = \{0,\ldots,9,A,\ldots,F\}$). Let some configuration $s$ have 0011 in the working tape, the head in the input tape is in position 26, and the head in the input tape is in position 2 (we consider 0-indexed positions). Also, $Q = \{q_1,\ldots,q_5\}$ and the current state is $q_3$.
	
	As a first approach, we will use a 9-tuple $\bar{a} = (a_1,\ldots,a_9)$ to represent $s$. That is, $(a_1,a_2) = (1,A)$ represent the position of the head in the input tape, $a_3 = 2$ represents the position of the head in the working tape, $a_4 = C$ (1100b in base 16) represents the content of the working tape, and $(a_5,\ldots,a_9) = (0,0,1,0,0)$ represents the current state. Then $\bar{a} = (1,A,2,C,0,0,1,0,0)$ will represent $s$.
	
	The problem that arises from this representation, is that to describe a transition in $M$ we need to read an arbitrary character in the working tape, and therefore we have to obtain the $a_3$-th bit in $a_4$. Furthermore, to get the following configuration, we need compute $a_4$ with the $a_3$-th bit flipped. This is generally not possible to describe with an $FO$ formula. Consider the following procedure that receives $x = a_4$ and $i = a_3$.
	
	\begin{algorithm} \label{switch1to0}
	\caption{If the $i$-th bit in $x$ is 1 replace it by 0 and return the result}
	\begin{algorithmic}
		\State $u \gets x,\; j \gets i$ \Comment{Get the $i$-th bit on $x$ and store it in $u$}
		\While{$j > 0$}
		\State $v \gets 0$
		\While{$u > 1$}
		\State $u \gets u-2,\; v \gets v+1$
		\EndWhile
		\State $u\gets v,\; j \gets j-1$
		\EndWhile
		\While{$u > 1$}
		\State $u \gets u-2$
		\EndWhile
		\State $\textbf{assert } u = 1$ \Comment{If $u \neq 1$ simply stop}	
		\State $y \gets 1$ \Comment{Compute $2^i$ and store it in $y$}
		\While{$i > 0$}
		\State $z \gets 0$
		\While{$y > 0$}
		\State $z \gets z+2,\; y \gets y-1$
		\EndWhile
		\State $i \gets i-1,\; y \gets z$
		\EndWhile
		\While{$y > 0$} \Comment{Substract $y$ from $x$}
		\State $x \gets x-1,\; y \gets y-1$
		\EndWhile
		\State \Return $x$.
	\end{algorithmic}
	\end{algorithm}	
	Each of the instructions can be expressed with $\fo$, so our strategy is to use the $\pth$ operator to simulate the algorithm and then we can describe a transition using the processed value of $a_4$. Note that we need to describe three more procedures to simulate the transitions for $0\to 0$, $0 \to 1$ and $1\to 1$.
	
	We will now describe how to simulate both the procedure and the transition. A procedure tuple $\bar{p} = (a_1,\ldots,a_{3+c+\ell},b_1,b_2,c_1,c_2,c_3,d_1,\ldots,d_{5c+2})$ represents the current configuration of $M(w)$ in $a_1,\ldots,a_{2+c+\ell}$, the values that will be read and written in the working tape in $b_1,b_2$, the instruction pointer in $c_1,c_2,c_3$ and the values stored in memory in $d_1,\ldots,d_{10c+2}$. In detail:
	\begin{enumerate}
		\item $a_1,a_2$ and $a_3$ represent the position of the head in the input tape and the working tape, respectively, $a_4,\ldots,a_{3+c}$ represent the content of the working tape and $a_{4+c},\ldots,a_{3+c+\ell}$ represent the current state in the current configuration that is being processed.
		\item $b_1$ and $b_2$ are equal to the value that is being read in the working tape and the value that will be written in the working tape respectively.
		\item $c_1,c_2,c_2$ represent the instruction pointer in the procedure. Only 8 different instructions are needed in the simulation.
		\item Each value in memory of $x,y,z,u,v$ need $c$ elements to represent them and $i,j$ need only one. We map $(d_1\ldots,d_{c}) \to x$, $(d_{c+1}\ldots,d_{2c}) \to y$,
		$(d_{2c+1}\ldots,d_{3c}) \to z$, $(d_{3c+1}\ldots,d_{4c}) \to u$,
		$(d_{4c+1}\ldots,d_{5c}) \to v$, $d_{5c+1} \to i$ and $d_{5c+2}\to j$.
	\end{enumerate}
	For each transition $\delta \subseteq Q \times \{0,1\} \times \{0,1\} \times Q \times \{-1,=,+1\} \times \{0,1\} \times \{-1,=,+1\}$ we define a formula $\varphi_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v})$, where $\bar{x} = (x_1,\ldots,x_{3+c+\ell})$, $\bar{s} = (s_1,s_2)$, $\bar{w} = (w_1,w_2,w_3)$, $\bar{u} = (u_1,\ldots,u_{5c+2})$, $\bar{y} = (y_1,\ldots,y_{3+c+\ell})$, $\bar{t} = (t_1,t_2)$, $\bar{z} = (z_1,z_2,z_3)$ and $\bar{v} = (v_1,\ldots,v_{5c+2})$ that describes the procedure to compute the values in the configuration and the transition itself. We will describe the formula part by part. Suppose $\delta = (q_i,a,1,q_j,op_1,0,op_2)$, so we have to simulate Algorithm \ref{switch1to0}.
	
	We start from instruction 0, which means that the procedure has not started yet and every value in the tuple is 0 except for the configuration values. It also initializes all the values in the tuple to 0 except for $x,u,i,j$.
	\begin{multline*}
	\varphi^{0,1}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{0,0}(s_1,s_2)\wedge\varphi^b_0(\bar{w}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_1(\bar{z})\, \wedge \\ 
	\bigwedge_{i = 1}^c v_i = x_{3+i} \wedge \bigwedge_{i = c+1}^{2c} \varphi_0(v_i) \wedge \bigwedge_{i = 2c+1}^{3c} \varphi_0(v_i) \wedge \bigwedge_{i = 1}^c v_{3c+i} = x_{3+i} \wedge \bigwedge_{i = 4c+1}^{5c} \varphi_0(v_i) \wedge v_{5c+1} = x_3 \wedge v_{5c+2} = x_3.
	\end{multline*}
	Instruction 1 which checks whether the value of $j$ ($d_{5c+2}$ in the tuple) is more than 0 or not, and then proceeds to instruction 2 or 3 on each case.
	\begin{multline*}
	\varphi^{1,2}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 
	\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_1(\bar{w}) \wedge \neg \varphi_0(u_{5c+2}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_2(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i, \\
	\varphi^{1,3}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 
	\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_1(\bar{w}) \wedge \varphi_0(u_{5c+2}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_3(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i.
	\end{multline*}
	Instruction 2 checks the value of $u$ ($d_{3c+1},\ldots,d_{4c}$ in the tuple). If it is $> 1$ then it substracts 2 from $u$ and adds 1 to $v$ ($d_{4c+1},\ldots,d_{5c}$ in the tuple), then repeats instruction 2. If it is equal to 0 or 1, then moves the value of $v$ to $u$, substracts 1 from $j$ and goes back to instruction 1.
	\begin{multline*}
	\varphi^{2,2}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 
	\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_2(\bar{w}) \wedge \neg \varphi^m_0(u_{3c+1},\ldots,u_{4c}) \wedge \neg \varphi^m_1(u_{3c+1},\ldots,u_{4c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_2(\bar{z})\, \wedge \\
	\bigwedge_{i = 1}^c u_i = v_i \wedge
	\bigwedge_{i = c+1}^{2c} u_i = v_i \wedge
	\bigwedge_{i = 2c+1}^{3c} u_i = v_i \wedge
	\varphi^m_{-2}(u_{3c+1},\ldots,u_{4c},v_{3c+1},\ldots,v_{4c})\, \wedge \\
	\varphi^m_{+1}(u_{4c+1},\ldots,u_{5c},v_{4c+1},\ldots,v_{5c}) \wedge u_{5c+1} = v_{5c+1} \wedge u_{5c+2} = v_{5c+2}. \\
	\varphi^{2,1}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_2(\bar{w}) \wedge ( \varphi^m_0(u_{3c+1},\ldots,u_{4c}) \vee \varphi^m_1(u_{3c+1},\ldots,u_{4c})) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_1(\bar{z})\, \wedge \\
	\bigwedge_{i = 1}^c u_i = v_i \wedge
	\bigwedge_{i = c+1}^{2c} u_i = v_i \wedge
	\bigwedge_{i = 2c+1}^{3c} u_i = v_i \wedge
	\bigwedge_{i = 3c+1}^{4c} u_{c+i} = v_i \wedge
	\varphi^m_0(v_{4c+1},\ldots,v_{5c}) \wedge
	u_{5c+1} = v_{5c+1} \wedge \varphi_{-1}(u_{5c+2},v_{5c+2}).	
	\end{multline*}
	Instruction 3 calculates the value of $u \mod 2$, that is, it repeats instruction 3 until the value of $u$ is equal to 0 or 1. On each iteration, it substracts 2 from $u$. Moreover, if the value of $u$ at the end of the iterations is not 1 then there is no step defined.
	\begin{multline*}
	\varphi^{3,3}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_3(\bar{w}) \wedge \neg \varphi^m_0(u_{3c+1},\ldots,u_{4c}) \wedge \neg \varphi^m_1(u_{3c+1},\ldots,u_{4c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_3(\bar{z})\, \wedge \\
	\bigwedge_{i = 1}^c u_i = v_i \wedge
	\bigwedge_{i = c+1}^{2c} u_i = v_i \wedge
	\bigwedge_{i = 2c+1}^{3c} u_i = v_i \wedge
	\varphi^m_{-2}(u_{3c+1},\ldots,u_{4c},v_{3c+1},\ldots,v_{4c}) \wedge
	\bigwedge_{i = 4c+1}^{5c} u_i = v_i \wedge
	u_{5c+1} = v_{5c+1} \wedge u_{5c+2} = v_{5c+2}, \\
	\varphi^{3,3}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 
	\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_3(\bar{w}) \wedge \varphi^m_1(u_{3c+1},\ldots,u_{4c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_4(\bar{z})\, \wedge \\
	\bigwedge_{i = 1}^c u_i = v_i \wedge
	\varphi^m_1(v_{c+1},\ldots,v_{2c}) \wedge
	\bigwedge_{i = 2c+1}^{3c} u_i = v_i \wedge
	\bigwedge_{i = 3c+1}^{4c} u_i = v_i \wedge
	\bigwedge_{i = 4c+1}^{5c} u_i = v_i \wedge
	u_{5c+1} = v_{5c+1} \wedge u_{5c+2} = v_{5c+2}
	\end{multline*}
	Instruction 4 checks the value of $i$ ($d_{5c+1}$ in the tuple.) If it is not 0 then goes to instruction 5 and if is 0 then goes to instruction 6. Moreover it initializes the value of $z$ ($d_{2c+1},\ldots,d_{3c}$ in the tuple) to 0 (which was 0 all along.)
	\begin{multline*}
	\varphi^{4,5}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_4(\bar{w}) \wedge \neg \varphi_0(u_{5c+1}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_5(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i, \\
	\varphi^{4,6}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_4(\bar{w}) \wedge \varphi_0(u_{5c+1}) \wedge \varphi_{1,0}(t_1,t_2) \wedge 	\varphi^b_6(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i.
	\end{multline*}
	Instruction 5 checks the value of $y$ ($d_{c+1},\ldots,d_{2c}$ in the tuple.) If it is more than 0 then it adds 2 to $z$ and substracts 1 from $y$, then repeats instruction 2. If it is not, then copies the value of $z$ to $y$ and subtracts 1 from $i$ and returns to instruction 4.
	\begin{multline*}
	\varphi^{5,5}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_5(\bar{w}) \wedge \neg \varphi^m_0(u_{c+1},\ldots,u_{2c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_5(\bar{z}) \, \wedge \\
	\bigwedge_{i = 1}^c u_i = v_i \wedge
	\varphi^m_{-1}(u_{c+1},\ldots,u_{2c},v_{c+1},\ldots,v_{2c}) \wedge
	\varphi^m_{+2}(u_{2c+1},\ldots,u_{3c},v_{2c+1},\ldots,v_{3c})\, \wedge \\
	\bigwedge_{i = 3c+1}^{4c} u_i = v_i \wedge
	\bigwedge_{i = 4c+1}^{5c} u_i = v_i \wedge
	u_{5c+1} = v_{5c+1} \wedge u_{5c+2} = v_{5c+2}, \\
	\varphi^{5,4}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_5(\bar{w}) \wedge \varphi^m_0(u_{c+1},\ldots,u_{2c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_4(\bar{z}) \, \wedge \\
	\bigwedge_{i = 1}^c u_i = v_i \wedge
	\bigwedge_{i = c+1}^{2c} u_{c+i} = v_i \wedge
	\varphi^m_0(v_{2c+1},\ldots,v_{3c}) \wedge
	\bigwedge_{i = 3c+1}^{4c} u_i = v_i \wedge
	\bigwedge_{i = 4c+1}^{5c} u_i = v_i \wedge
	\varphi_{-1}(u_{5c+1},v_{5c+1}) \wedge u_{5c+2} = v_{5c+2}
	\end{multline*}
	Instruction 6 checks the value of $y$. If it is more than 0, then subtracts 1 from $x$ and $y$ and repeats instruction 6. If it is not, then goes to instruction 7.
	\begin{multline*}
	\varphi^{6,6}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_6(\bar{w}) \wedge \neg \varphi^m_0(u_{c+1},\ldots,u_{2c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_6(\bar{z}) \, \wedge \\
	\varphi^m_{-1}(u_1,\ldots,u_c,v_i,\ldots,v_c) \wedge \varphi^m_{-1}(u_{c+1},\ldots,u_{2c},v_{c+1},\ldots,v_{2c}) \wedge \bigwedge_{i = 3c+1}^{5c+2} u_i = v_i]\,\vee \\
	\varphi^{6,7}_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = \varphi_{1,0}(s_1,s_2) \wedge \varphi^b_6(\bar{w}) \wedge \varphi^m_0(u_{c+1},\ldots,u_{2c}) \wedge \varphi_{1,0}(t_1,t_2) \wedge \varphi^b_7(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i.
	\end{multline*}
	Instruction 7 stores the value of $x$ after the corresponding bit has been switched. Then we can define $\varphi_{\delta}$ which also simulates the actual transition. If $u$ equals 1, then copy what is stored in $x$ to $a_4,\ldots,a_{3+c}$, go from state $q_i$ to state $q_j$, and move the heads to their corresponding positions.
	\begin{multline*}
	\varphi_{\delta}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) = 	[\bigwedge_{i = 1}^{3+c+\ell} x_i = y_i \wedge (\varphi^{0,1}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{1,2}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v})\, \vee \\ \varphi^{1,3}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{2,2}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{2,1}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{3,3}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \\ \varphi^{3,4}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{4,5}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{4,6}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{5,5}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \\ \varphi^{5,6}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{6,6}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}) \vee \varphi^{6,7}(\bar{x},\bar{s},\bar{w},\bar{u},\bar{y},\bar{t},\bar{z},\bar{v}))] \, \vee \\
	[\varphi_{1,0}(s_1,s_2) \wedge \varphi^b_7(\bar{w}) \wedge \varphi^m_1(u_{3c+1},\ldots,u_{4c}) \wedge \varphi_{0,0}(t_1,t_2) \wedge \varphi^b_0(\bar{z}) \wedge \bigwedge_{i = 1}^{5c+2} u_i = v_i \,\wedge \\
	\varphi^2_{op_1}(x_1,x_2,y_1,y_2) \wedge \varphi_{op_2}(x_3,y_3) \wedge \bigwedge_{i = 1}^c u_i = x_{3+i} \wedge \varphi^q_i(x_{4+c},\ldots,x_{3+c+\ell}) \wedge \varphi^q_j(y_{4+c},\ldots,y_{3+c+\ell})].
	\end{multline*}
	Note that we also need to specify that the program we are following is Algorithm \ref{switch1to0} so we store $1,0$ in $b_1,b_2$ all along the procedure. We now describe the three other algorithms that compute the switches from $0\to 0$, $0\to 1$ and $1\to 1$.
\end{proof}

\begin{theorem}
	$\tqso(\fo)$ captures $\shp$ over the class of ordered structures.
\end{theorem}

\begin{theorem}
	($\qfo(\lfp)$ or $\qfo(\fo)$) with algebraic least fixed point operator captures $\totp$ over the class of ordered structures.
\end{theorem}
	

\begin{theorem}
$\eqso(\fo)$ captures $\shp$ over the class of ordered structures.
\end{theorem}

\begin{proposition}
$\eqso(\fo)$ does not capture $\shp$ over the class of all structures.
\end{proposition}

%\begin{theorem}
%$\eqso(\integ,\fo)$ captures $\gp$ over the class of ordered structures.
%\end{theorem}


\begin{theorem}
$\eqso(\eso)$ captures $\spp$ over the class of ordered structures.
\end{theorem}
